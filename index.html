<!DOCTYPE HTML>
<!--
	Astral by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Welcome!</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
		<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/styles/default.min.css">
		<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/highlight.min.js"></script>
	</head>
	<body class="is-preload">
			<div id="black-screen">
				<p id="boot-sequence"></p>
			</div>
		<div class="mouse-light" id="mouse-light"></div>

		<!-- Wrapper-->
			<div id="wrapper">

				<!-- Nav -->
					<nav id="nav">
						<a href="#" class="icon solid fa-home"><span>Home</span></a>
						<a href="#work" class="icon solid fa-folder"><span>Work</span></a>
						<a href="#blog" class="icon solid fa-pencil-alt"><span>Blog</span></a>
						<a href="#contact" class="icon solid fa-envelope"><span>Contact</span></a>
						<a href="#about-me"><img src="images/icon.png" alt="Icon" style="width: 0.7em; height: 0.7em;"><span>About Me!</span></a>
					</nav>

				<!-- Main -->
					<div id="main">

						<!-- Me -->
							<article id="home" class="panel intro">
								<header>
									<h1 class="blur-text">TayLee Young<span class="blinking-cursor">|</span></h1>
											<p>Systems Programmer and Game Designer</p>
										<!--<img src="images/me.jpg" alt="" /> -->
										<!-- ASCII Art Container -->
										<pre id="ascii-art-container"></pre>
								</header>
							</article>

						<!-- Work -->
							<article id="work" class="panel">
								<header>
									<h2 class="blur-text">Featured Work<span class="blinking-cursor">|</span></h2>
								</header>
								<p>
									Here is some of my most recent work! Some are still in production, some are finished.
									This work showcases my skills in programming, game design, and systems. 
									<br>
									<br>
									<!-- Projects that I have lost access to their original source code, as well as commentary
									on my experiences in this field can be found within the <a href="#blog">Blog</a> section, so feel free to 
									check that out as well! -->
									I will be adding a blog section soon, which covers some other projects I have worked on, as well as my
									thoughts on other related technological topics, so stay tuned for that!
								</p>
								<section>
									<div class="row">
										<div class="col-12">
											<figure>
												<a href="#work1" class="image fit"><img src="images/pic04.jpg" alt=""></a>
												<figcaption><i>SHUTTLEFALL</i></figcaption>
												<figcaption> Aliens, corrupt business practices, and a <i>massive</i> drill.</figcaption>
											</figure>
										</div>
										<div class="col-12">
											<figure>
												<a href="#work2" class="image fit"><img src="images/mothTitleScreen.gif" alt=""></a>
												<figcaption><i>Moth 2: The Mothening</i></figcaption>
												<figcaption>From fluttering wings to fortune -- grow your moth empire!</figcaption>
											</figure>
										</div>
										<div class="col-12">
											<figure>
												<a href="#work3" class="image fit"><img src="images/refractionTitleScreen.gif" alt=""></a>
												<figcaption><i>Refraction</i></figcaption>
												<figcaption>A custom engine running CPU-based pixel-by-pixel light calculations? 
													How hard can that be?
												</figcaption>
											</figure>
										</div>
										<div class="col-12">
											<figure>
												<a href="#work4" class="image fit"><img src="images/PDthumbnail.png" alt=""></a>
												<figcaption><i>Procedurally Generated Dungeon</i></figcaption>
												<figcaption>What happens when you try to design a playable level using
													entirely procedurally generated layouts?
												</figcaption>
											</figure>
										</div>
									</div>
								</section>
							</article>

							<style>
								figure {
									margin-bottom: 10rem;
								}
							
								figcaption {
									margin-top: 0.5rem;
									text-align: center;
								}
							</style>

						<!-- Work 1 -->
							<article id="work2" class="panel">
								<header>
									<h2><strong><i>Moth 2: The Mothening</i></strong></h2>
								</header>
								<p>
									On an alien planet, moths grow to be 5x the size of the ones we find on earth. 
									They are cute, cuddly, and worth quite the price. You set up base on this planet,
									creating a greenhouse as your base of operations. Alone on the planet, you seek to
									catch, breed, and sell moths all in an attempt to become a monopoly. 
									<br>
									It's hard to sell these guys with how cute they are though...
									<br>
									This was the core concept of a game my team and I were developing during our third 
									and potentially fourth years at DigiPen. It's still currently in development, but
									I would like to give a glimpse on what I was working on. It's roughly 5-6 months into
									development at this point, with most important features nearly fleshed out. 
									I am the lead systems programmer, as well as a Technical Advocate. My job is to 
									assign tasks, manage timelines, work with the producers and designers on implenting 
									their ideas, and handle interdisciplinary communication. I also have a hand in designing
									and programming most systems within the game. All of this was done in Unreal Engine 5, 
									not only the first time I've used this engine, but also the first time I've used a 
									commercial engine to this extent before. This was another massive learning process, 
									but I feel as if this is one of my most personally successful projects yet. This 
									project has had many ups and downs, and is not in its best shape right now, yet
									I cannot be anything but proud of the work put in. 
									<br>
									<br>
									<h2>The Rocky Beginning</h2>
									Originally, this game was planned to be a sort of economy simulator experience.
									Your main focus was to sell all the moths you catch for profit. So we knew from the 
									beginning one of the largest and most important systems was going to be the market system.
									I decided to take this monumental task on, knowing it would grant me the best chance at 
									truly exploring systems programming. I had some experience previously that brought me interest,
									but this would be the first time I was given such a large task. 
									But before we could sell anything, we had to catch moths first. This was the first mechanic we 
									implemented, followed by the breeding system, as we knew we also had to sell the different life
									stages of the moths as well. 
									<br>
									This gave me the break I needed to set up how I wanted to manage things. I took time to figure out
									what each programmer had skills in, how they wanted to communicate best, how we wanted to handle 
									task management. These were needed, and since I had to wait to implement the market, this was 
									the perfect time. The majority of this time was pretty cut-and-dry, only requiring iteration 
									in terms of timeline management. By the time I had my affairs in order, I still couldn't start
									on the market yet -- we had some new issues arise. Our source control was giving us more issues
									than we knew what to do with, miscommunications inbetween our departments, and overall trial and 
									error. 
									<br>
									<br>
									<h2>The Market</h2>
									It took several weeks of focus almost entirely on my role as the Technical Advocate before I could 
									even begin programming. Once I had the opportunity however, I swooped in. I focused on keeping the 
									prototype simple -- you put in a moth, you get money out. It was a set price for everything, with 
									no real control, but it was a start! I allowed the designers to begin planning out how they wanted 
									the system to go. After many spreedsheets and discussions, we had several things we wanted the market 
									to do -- and it was going to take a lot of effort. As the other programmers had their own personal
									tasks and goals to work on, this was something I focused on nearly entirely on my own. 
									<br>
									To break it down simply, the overview of the cost price was calculated as follows, starting with 
									the moment the player presses 'sell':
									<ul>
										<li>
											We check if the moth is wild caught or bred first, as this impacts the inital base price,
											prior to all modifications. Wild caught moths sell for less, relative to their base price.
										</li>
										<li>
											We check the moth's quality -- the most impacting factor of their price. Each moth species
											holds a unique graph on their selling prices in relation to their quality. Some moths are 
											close to linear, some are more logarithmic, and some are more like a sine. 
											<ul>
												<li>
													We take the quality and the species into a special formula created to create the 
													sell price based on the graph described above. Lots of finicky decimal values that
													are used here, all of which change based on which species it is.
												</li>
												<li>
													Additional fact: all of the assigning of the quality was done by me! It also
													required a unique system, which calculated the percentage chance (based on multiple factors)
													of what quality type a moth could spawn with, as well as the exact quality numerical value 
													based on the distribution of that type!
												</li>
											</ul>
										</li>
										<li>
											Similar to how a real life stock market works, every ten minutes different moth species have a new 
											demand, increasing or decreasing their price. The chance of a price change, and how much it changes
											is also relative to whether or not it was recently in demand. 
										</li>
									</ul>
									<br>
									Of course, as I said, this is a massive simplification of the calculations, but it gives a good idea on how 
									it all works. This system relied heavily on other systems as well -- quality, a market cycle, species distribution,
									etc. which made this process take approximately five months of work. It required a lot of creativity on how to 
									best interconnect each of these systems and mechanics. As well as reinforce my skills in communication, debugging,
									and overall systems programming. 
									<br>
									<br>
									<h2>Continuing Development</h2>
									<br>
									By this point, we had some hefty systems in play already, with more to come. Our three main mechanics, catching, breeding, 
									and selling, were pretty solid by this point. But we needed new things to keep it fresh and interesting -- a demand from the 
									player to constantly be rotating their interest. We moved towards pinning and companion moths -- ways to get slight boosts
									like jumping higher, or having a better chance at higher quality. You should also feed your moth friends, in order to keep 
									them from running away. By exploring, you find all sorts of foods, as well as new moths! You can even give your moths some 
									homes to keep them safe and cozy within the greenhouse.
									<br>
									But, unfortunately, as game development usually goes, many of these ideas didn't work out as planned.
									<br>
									As I continued to lead and program throughout this project, it wasn't long before we ran into more issues. Constant
									changes in design leading to repeated refactoring and scrapping of mechanics, losing our art team due to miscommunications 
									and poor management, teammate illnesses, source control difficulties, and more. This had lead production to slow to a crawl, 
									posing a risk of failure with the project. Many of the systems I have worked on or outright created had been changed due to 
									design choices. In truth, the outlook of continuing production may be bleak at this point. 
									<br>
									Nonetheless, I can say with absolute certainty that I am, and will always be, proud of the work I put in. I am proud of the
									team's efforts work and the memories I made! I experienced, developed, and gained skills that I may not have in a different
									situation. Whether or not development continues, I find myself constantly looking to build on everything I have learned thus far.
								</p>
								<!-- Code Snippets Section -->
								<section>
									<h3 class="code-toggle">
										Code Snippets: Simple Engine Implementation
										<img src="images/DropDown.png" alt="Dropdown Icon">
									</h3>
									<pre class="code-snippet"><code class="language-cpp">
// singleton instance
Engine* Engine::instance = new Engine();

Engine::EngineCode Engine::Start()
{
	// time instance
	time = new Time();

	AudioManager.LoadMusicFromJSON("./Data/music.json");
	AudioManager.LoadSFXFromJSON("./Data/SFX.json");
	// initalize all systems
	for (int i = 0; i < systemCount; ++i)
	{
		try
		{
			systems[i]->Init();
		}
		catch (EngineCode engineFailure)
		{
			assert(engineFailure && "Engine failed to initialize. Location: Engine::Start(), Init()");
			return engineFailure;
		}
	}

	// main game loop
	while (isRunning && !closeRequested)
	{
		EngineCode code = NothingBad;

		try
		{
			code = Update();
		}
		catch (EngineCode updateFailure)
		{
			assert(updateFailure && "Engine failed during update. Location: Engine::Start(), Update()");
			return updateFailure;
		}
		if (code == CloseWindow)
			break;

		try
		{
			code = Render();
		}
		catch (EngineCode renderFailure)
		{
			assert(renderFailure && "Engine failed during render. Location: Engine::Start(), Render()");
			return renderFailure;
		}
		if (code == CloseWindow)
			break;
	}

	// stop engine
	return Stop();
}

Engine::EngineCode Engine::Stop()
{
	try
	{
		ShutDown();
	}
	catch (EngineCode shutdown)
	{
		assert(shutdown && "Engine failed to shut down. Location: Engine::Stop(), ShutDown()");
		return shutdown;
	}

	return EngineExit;
}

void Engine::EngineAddSystem(BaseSystem* sys)
{
	systems[systemCount++] = sys;
}

bool Engine::Paused()
{
	return paused;
}

void Engine::SetPause(bool pause)
{
	paused = pause;
}

// get the singleton instance
Engine* Engine::GetInstance()
{
	if (instance == nullptr)
	{
		instance = new Engine();
	}
	return instance;
}

Engine::Engine() : isRunning(true), systemCount(0), systems(), paused(false), time(NULL), closeRequested(false)
{
}

Engine::~Engine()
{
	if (instance != NULL)
	{
		delete instance;
	}
}

Engine::EngineCode Engine::Update()
{
	float dt = Time::Instance().Delta();

	// update all systems
	for (int i = 0; i < systemCount; ++i)
	{
		try {
			systems[i]->Update(dt);
		}
		catch (EngineCode updateFailure)
		{
			switch (updateFailure)
			{
			case CloseWindow:
				return updateFailure;
			default:
				assert(updateFailure && "Engine failed during system update. Location: Engine::Update()");
				throw(updateFailure);
			}
		}
	}
	return NothingBad;
}

Engine::EngineCode Engine::Render()
{
	// render all systems
	for (int i = systemCount; ++i)
	{
		systems[i]->Render();
	}
	return NothingBad;
}

Engine::EngineCode Engine::ShutDown()
{
	// close all systems
	for (int i = systemCount - 1; i >= 0; --i)
	{
		systems[i]->Close();
	}

	delete time;
	AudioManager.Free();
	return EngineExit;
}

// set flag to close game engine for whatever reasons you want
void Engine::SetCloseRequest(bool close)
{
	closeRequested = close;
}
										</code></pre>
								</section>
							</article>

						<!-- Work 2 -->
							<article id="work3" class="panel">
								<header>
									<h1><strong><i>Refraction</i></strong></h1>
								</header>
								<p>
									You find yourself lost in the depths of a dungeon. It's dark, damp, and cramped.
									Equipped with a solitary light, you venture forward, discovering large crystals
									that can shift and redirect light beams. Soon, it dawns on you — manipulating 
									these beams unlocks pathways, each puzzle leading closer to an escape.
									<br>
									This was the core concept of a game my team and I developed during our second
									year of college at DigiPen Institute of Technology. The game was called Refraction,
									a nod to the lighting mechanic that was the core of the game. The game spanned a 
									full academic year, and the game was created entirely in a custom-made engine.
									As the engine programmer, I was responsible for building the engine from the ground
									up using a limited toolkit: JSON, SDL2, ImGui, and OpenGL. With just a year of programming
									experience — and even less in C++ — this role was both a challenge and a major
									opportunity for growth.
									<br>
									<h2>Building the Engine</h2>
									<br>
									The first hurdle was getting the engine up and running within a tight time constraint.
									We needed a functional prototype as quickly as possible to support the rest of the team. 
									I knew that I needed to build a solid foundation that could be expanded upon later, especially
									for the lighting systems that would be created by our graphics programmer. I leaned heavily
									on preventative measures: designing the code to handle potential errors gracefully and 
									implementing safe coding practices. While the initial steps of creating a custom engine were
									daunting, I managed to produce a basic framework in just two weeks. This framework included
									input handling, scene management, level loading, basic rendering, debugging tools, and anything
									else I could think of that would be useful for the team.
									<br>
									Working on the engine gave me a newfound appreciation for aspects of game development that
									are often invisible to end users. Creating features like scene transitions and level 
									management from scratch revealed the intricacies involved and the importance of a solid
									foundation. In addition, there were countless design choices I had to weigh in on. What engine
									design pattern should I choose? Observer? Composite? Singleton? There was so much to consider,
									but I opted for the singleton pattern due to its simplicity and ease of use. This was just one of
									many decisions that would shape the engine's architecture and the game's development.
									As someone who previously took these systems for granted when using professional
									engines, this was an eye-opening experience.
									<br>
									<br>
									<!-- New Code Snippets Section -->
									<section>
										<h3 class="code-toggle">
											Code Snippets: Simple Engine Implementation
											<img src="images/DropDown.png" alt="Dropdown Icon">
										</h3>
										<pre><code class="language-cpp">
// singleton instance
Engine* Engine::instance = new Engine();

Engine::EngineCode Engine::Start()
{
	// time instance
	time = new Time();

	AudioManager.LoadMusicFromJSON("./Data/music.json");
	AudioManager.LoadSFXFromJSON("./Data/SFX.json");
	// initalize all systems
	for (int i = 0; i < systemCount; ++i)
	{
		try
		{
			systems[i]->Init();
		}
		catch (EngineCode engineFailure)
		{
			assert(engineFailure && "Engine failed to initialize. Location: Engine::Start(), Init()");
			return engineFailure;
		}
	}

	// main game loop
	while (isRunning && !closeRequested)
	{
		EngineCode code = NothingBad;

		try
		{
			code = Update();
		}
		catch (EngineCode updateFailure)
		{
			assert(updateFailure && "Engine failed during update. Location: Engine::Start(), Update()");
			return updateFailure;
		}
		if (code == CloseWindow)
			break;

		try
		{
			code = Render();
		}
		catch (EngineCode renderFailure)
		{
			assert(renderFailure && "Engine failed during render. Location: Engine::Start(), Render()");
			return renderFailure;
		}
		if (code == CloseWindow)
			break;
	}

	// stop engine
	return Stop();
}

Engine::EngineCode Engine::Stop()
{
	try
	{
		ShutDown();
	}
	catch (EngineCode shutdown)
	{
		assert(shutdown && "Engine failed to shut down. Location: Engine::Stop(), ShutDown()");
		return shutdown;
	}

	return EngineExit;
}

void Engine::EngineAddSystem(BaseSystem* sys)
{
	systems[systemCount++] = sys;
}

bool Engine::Paused()
{
	return paused;
}

void Engine::SetPause(bool pause)
{
	paused = pause;
}

// get the singleton instance
Engine* Engine::GetInstance()
{
	if (instance == nullptr)
	{
		instance = new Engine();
	}
	return instance;
}

Engine::Engine() : isRunning(true), systemCount(0), systems(), paused(false), time(NULL), closeRequested(false)
{
}

Engine::~Engine()
{
	if (instance != NULL)
	{
		delete instance;
	}
}

Engine::EngineCode Engine::Update()
{
	float dt = Time::Instance().Delta();

	// update all systems
	for (int i = 0; i < systemCount; ++i)
	{
		try {
			systems[i]->Update(dt);
		}
		catch (EngineCode updateFailure)
		{
			switch (updateFailure)
			{
			case CloseWindow:
				return updateFailure;
			default:
				assert(updateFailure && "Engine failed during system update. Location: Engine::Update()");
				throw(updateFailure);
			}
		}
	}
	return NothingBad;
}

Engine::EngineCode Engine::Render()
{
	// render all systems
	for (int i = systemCount; ++i)
	{
		systems[i]->Render();
	}
	return NothingBad;
}

Engine::EngineCode Engine::ShutDown()
{
	// close all systems
	for (int i = systemCount - 1; i >= 0; --i)
	{
		systems[i]->Close();
	}

	delete time;
	AudioManager.Free();
	return EngineExit;
}

// set flag to close game engine for whatever reasons you want
void Engine::SetCloseRequest(bool close)
{
	closeRequested = close;
}
										</code></pre>
									</section>
									<h2>Optimizing Performance</h2>
									<br>
									One of the most significant challenges we faced was performance optimization. Our game 
									initially struggled to maintain even 30 FPS. Given my familiarity with the engine, I took 
									the lead in diagnosing bottlenecks. This required diving into the graphics programmer's code,
									experimenting with Visual Studio's Profiler, and creating ImGui tools to track performance metrics
									in real time.
									<br>
									A key decision was made right before this optimization phase: our graphics programmer wanted to
									perform lighting calculations on the CPU rather than the GPU. The lighting system relied on pixel-by-pixel
									math calculations, and using the CPU allowed the graphics programmer to maintain precise control over each
									individual pixel. While this method offered flexibility and allowed for the unique lighting effect we sought
									to create, it came at the cost of significant performance overhead. GPUs are designed for parallel processing
									and would typically be far more efficient for this type of computation. However, at the time, our team prioritized
									the control and simplicity of the CPU-based approach. We wanted to test the boundaries of what we could do, and
									although this decision contributed to the challenges we faced in maintaining stability and performance, it also 
									allowed us to create a unique and visually striking game. 
									<br>
									While I made some improvements, my limited experience meant there were persistent inefficiencies. Despite my best 
									efforts, we couldn't fully address all performance issues within the project's timeline. This was a tough lesson:
									foundational code quality and ongoing maintenance are crucial for long-term success. Our struggles reinforced
									the importance of clean, maintainable code, and proactive profiling —— lessons that I've carried into every project since.
									<br>
									<br>
									<div class="gallery">
										<a href="#pic05" class="thumbnail"><img src="images/refractiondemo.gif" alt="Example of lighting and gameplay."></a>
									</div>
									<br>
									<br>
									<h2>Developing an Editor</h2>
									<br>
									With the engine stable enough for continuing production, I took on the task of developing a level editor to streamline
									the designers' workflow. Using ImGui, I built an interface that allowed designers to add and remove entities, import 
									layouts from their planning tools, and adjust properties dynamically. This task required me to dive deep into 
									ImGui's documentation and address compatibility challenges with our engine's OpenGL and SDL2 setup. The process was 
									slow at first, but the final editor significantly improved the team's efficiency. 
									<br>
									Beyond the core editor functionality, I added debugging tools to track entities and their statistics, tracking and allowing
									dynamic modification of particles, dynamic adjustments of lights, display lighting properties, level importing and saving
									from JSON, etc. These tools weren't just useful; they were essential for diagnosing issues during the final stages 
									of development. While the editor wasn't perfect, it marked a major milestone in my understanding of tool development 
									and user-focused design. This process was one of the most difficult, as the documentation was loaded with information
									I had to sort through, and the process of creating the editor was a trial-and-error process. The other programmers were
									essential to get this task done in time, and I am grateful for their help.
									<br>
									<br>
																	<!-- Code Snippets Section -->
								<section>
									<h3 class="code-toggle">
										Code Snippets: Entity Creation in Editor
										<img src="images/DropDown.png" alt="Dropdown Icon">
									</h3>
									<pre><code class="language-cpp">
int LevelCreatorScene::CreateCircleEntity()
{
	int circles_existing = 0;
	std::string number = "./Data/GameObjects/Circle";
	std::string filename = "./Data/GameObjects/Circle.json";

	Entity* temp = FileIO::GetInstance()->ReadEntity(filename);

	temp->addKey = "Circle";

	temp->key = "Circle" + std::to_string(circleCount);
	tempEntities.push_back(temp);
	++circleCount;
	return 0;
}

int LevelCreatorScene::CreateDoorEntity()
{
	int door_existing = 0;
	std::string number = "./Data/GameObjects/Door";
	std::string filename = "./Data/GameObjects/Door.json";

	Entity* temp = FileIO::GetInstance()->ReadEntity(filename);

	temp->addKey = "Door"; 

	temp->key = "Door" + std::to_string(doorCount);

	tempEntities.push_back(temp);
	++doorCount;
	return 0;
}

int LevelCreatorScene::CreateMirrorEntity(MirrorData mirror)
{
	int door_existing = 0;

	UNREFERENCED_PARAMETER(door_existing);

	std::string number = "./Data/GameObjects/Mirror";

	std::string filename;
	switch (mirror.spriteDirection) {
	case 1: filename = "./Data/GameObjects/MirrorTopLeft.json"; break;
	case 2: filename = "./Data/GameObjects/MirrorTopRight.json"; break;
	case 3: filename = "./Data/GameObjects/MirrorBottomLeft.json"; break;
	case 4: filename = "./Data/GameObjects/MirrorBottomRight.json"; break;
	default: return 0;
	}

	//classic naming conventions
	Entity* temp = FileIO::GetInstance()->ReadEntity(filename);
	temp->GetComponent<BehaviorMirror>()->SetReflection(mirror.direction);

	temp->addKey = "Mirror"; // this is for the map holding functions and gives access to function for circle

	temp->key = "Mirror" + std::to_string(mirrorCount);

	tempEntities.push_back(temp);
	++mirrorCount;
	return 0;
}

int LevelCreatorScene::CreateEmitterEntity(EmitterData emit)
{
	std::string number = "./Data/GameObjects/Emitter";
	std::string filename = "./Data/GameObjects/tempEmitter.json";

	Entity* temp = FileIO::GetInstance()->ReadEntity(filename);

	switch (emit.spriteDirection) {
	case 1:
	{
		BehaviorEmitter* mine = temp->GetComponent<BehaviorEmitter>();
		mine->SetDirection({ 0.0f, -1.0f });
		mine->SetPosition(*temp->GetComponent<Transform>()->GetTranslation());
		break;
	}
	case 2:
	{
		BehaviorEmitter* mine = temp->GetComponent<BehaviorEmitter>();
		mine->SetPosition(*temp->GetComponent<Transform>()->GetTranslation());
		mine->SetDirection({ 0.0f, 1.0f });
		break;
	}
	case 3:
	{
		BehaviorEmitter* mine = temp->GetComponent<BehaviorEmitter>();
		mine->SetDirection({ 1.0f, 0.0f });
		mine->SetPosition(*temp->GetComponent<Transform>()->GetTranslation());
		break;
	}
	case 4:
	{
		BehaviorEmitter* mine = temp->GetComponent<BehaviorEmitter>();
		mine->SetDirection({ -1.0f, 0.0f });
		mine->SetPosition(*temp->GetComponent<Transform>()->GetTranslation());
		break;
	}
	default: return 0;
	}
	temp->addKey = "Emitter"; // this is for the map holding functions and gives access to function for circle

	temp->key = "Emitter" + std::to_string(emitterCount);

	tempEntities.push_back(temp);
	++emitterCount;
	return 0;
}
									</code></pre>
								</section>
								<!-- New Code Snippets Section -->
								<section>
									<h3 class="code-toggle">
										Code Snippets: Scene Settings
										<img src="images/DropDown.png" alt="Dropdown Icon">
									</h3>
									<pre><code class="language-cpp">
ImGui::Text("Scene Settings");
ImGui::Text("./Data/Scenes/''LevelNameHere''");
if (ImGui::TreeNode("Export:"))
{
	ImGui::Text("TileMapOnly");
	ImGui::InputText(".json", myTextBuffer, sizeof(myTextBuffer));
	if (ImGui::Button("ExportTileMap"))
	{
		std::string exportFileName = std::string(myTextBuffer);
		if (exportFileName.empty())
		{
			ImGui::OpenPopup("EmptyExportFileNamePopup");
		}
		else if (!IsFileNameValid(exportFileName))
		{
			ImGui::OpenPopup("InvalidExportFileNamePopup");
		}
		else
		{
			FileIO::GetInstance()->ExportTileMap(myTextBuffer);
			ImGui::OpenPopup("SuccessfulExport");
		}
	}

	if (ImGui::Button("ExportFullScene"))
	{
		std::string exportFileName = std::string(myTextBuffer);
		if (exportFileName.empty())
		{
			ImGui::OpenPopup("EmptyExportFileNamePopup");
		}
		else if (!IsFileNameValid(exportFileName))
		{
			ImGui::OpenPopup("InvalidExportFileNamePopup");
		}
		else
		{
			ExportScene(myTextBuffer);
			ImGui::OpenPopup("SuccessfulExport");
		}
	}

	ImGuiManager::RenderOKPopup("SuccessfulExport", "Exported!");
	ImGuiManager::RenderOKPopup("EmptyExportFileNamePopup", "Please provide a file name for export!");
	ImGuiManager::RenderOKPopup("InvalidExportFileNamePopup", "Illegal characters in the tilemap name GOOBER!");

	ImGui::TreePop();
}

if (ImGui::TreeNode("Import:"))
{
	static char filenameBuffer[256];
	ImGui::InputText(".json", filenameBuffer, sizeof(filenameBuffer));

	ImGui::Text("NOTE: this will reset the current level.");
	{
		if (ImGui::Button("Submit"))
		{
			std::string filename = "./Data/Scenes/" + std::string(filenameBuffer) + ".json";

			if (std::string(filenameBuffer).empty())
			{
				ImGui::OpenPopup("EmptyImportFileNamePopup");
			}
			else if (!IsFileNameValid(filenameBuffer))
			{
				ImGui::OpenPopup("InvalidImportFileNamePopup");
			}
			else
			{
				std::ifstream file(filename);
				sceneName = std::string(filenameBuffer);
				if (file.is_open())
				{
					file.close();
					Renderer::GetInstance()->CleanRenderer();
					LevelBuilder::GetInstance()->LoadTileMap(filename);
					if (EntityContainer::GetInstance()->CountEntities() > 0)
					{
						int size = EntityContainer::GetInstance()->CountEntities();
						for (int i = 0; i < size; ++i)
						{
							if ((*EntityContainer::GetInstance())[i])
							{
								tempEntities.push_back((*EntityContainer::GetInstance())[i]);
								tempEntities[i]->addKey = tempEntities[i]->GetRealName();
								if (tempEntities[i]->GetRealName().compare("Player") == 0)
								{
									playerExists = true;
								}
							}
						}
					}
					json counts = FileIO::GetInstance()->OpenJSON("./Data/Scenes/" + std::string(filenameBuffer) + "OBJECTS.json");

					if (counts["Circle"].is_object())
					{
						circleCount = counts["Circle"]["count"];
					}
					if (counts["Door"].is_object())
					{
						doorCount = counts["Door"]["count"];
					}
					if (counts["Mirror"].is_object())
					{
						mirrorCount = counts["Mirror"]["count"];
					}
					if (counts["Emitter"].is_object())
					{
						emitterCount = counts["Emitter"]["count"];
					}
					if (counts["Receiver"].is_object())
					{
						ReceiverCount = counts["Receiver"]["count"];
					}

					if (!entityManager->InitializeProperties(filename + "OBJECTS.json"))
					{
						ImGui::OpenPopup("NoObjectsInScene");
					}

					ImGui::OpenPopup("SuccessfulImport");
				}
				else
				{
					ImGui::OpenPopup("FileNotFoundPopup");
				}
			}
		}

		ImGuiManager::RenderOKPopup("SuccessfulImport", "Successfully imported the scene!");

		ImGuiManager::RenderOKPopup("NoObjectsInScene", "Objects do not exist in this scene.");

		ImGuiManager::RenderOKPopup("EmptyImportFileNamePopup", "Please provide a file name for import!");

		ImGuiManager::RenderOKPopup("InvalidImportFileNamePopup", "Please provide a valid file name without illegal characters for import!");

		ImGuiManager::RenderOKPopup("InvalidImportFileNamePopup", "Please provide a valid file name without illegal characters for import!");

		ImGuiManager::RenderOKPopup("FileNotFoundPopup", "File not found!");
	}
	ImGui::TreePop();
}
									</code></pre>
								</section>
									<h2>Final Touches And Lessons</h2>
									<br> As time came to an end, I wrapped up the engine with some final touches to ensure everything was stable 
									and performed as we expected. I aided the graphics programmer in creating the menus —— another hand-made visual
									that tied together our stylization. And with that, we were done.
									<br>
									This project was a crucible of learning experiences:
									<br><strong>Engine Architecture</strong> - Designing the engine entirely myself taught me how critical it is to align 
									architecture with project requirements. The decision to use a singleton pattern, while simple and effective for a 
									student project, highlighted the trade-offs inherent in design decisions.
									<br><strong>Performance Optimization</strong> - Profiling tools and debugging performance bottlenecks were
									invaluable skills I developed. I learned that optimization is as much about identifying problems as it is about
									knowing when to prioritize other tasks. 
									<br><strong>Collaboration</strong> - While working in a small team led to more collaboration and effective communication,
									it also required me to take on multiple roles. I learned to balance my responsibilities and communicate effectively with
									what was needed for the project. This was also one of the first projects where I had to work in parallel with other programmers.
									It reinforced how important it was to provide clear documentation, maintain consistent and clean code, and communicate
									regularly with the team.
									<br><strong>Iterative Development</strong> - The necessity of balancing feature development with performance and usability 
									underscored the iterative nature of game development. As stated before, starting with and maintaining clean, well-documented 
									code is far easier than fixing problems either. Additionally, especially when it came to tool and engine development, I often
									had to go back and revise my work to accommodate new features or changes. This was a lesson in flexibility and adaptability.
									<br>
									<br>
									<h2>The Final Product</h2>
									<br>
									In the end, our team produced a functional, engaging puzzle game with dynamic lighting, handcrafted visuals, and satisfying
									gameplay. The experience taught me as much about teamwork and project management as it did about technical skills.
									From handling conflicts in code and within the team to finding creative solutions under pressure, this project laid the
									foundation for my future growth as a developer. 
									<br>
									To this day, I'm grateful for the challenges and lessons of this project. It wasn't perfect — far from it — but it
									was a pivotal experience in my journey as a programmer and game designer. The experience reinforced my passion for game 
									development and systems programming, and I carry the lessons with every project!

								</p>
							</article>

						<!-- Work 3 -->
							<article id="work4" class="panel">
								<header>
									<h2>Procedurally Generated Dungeon</h2>
								</header>
								<p>
									What happens, as a game developer, when you attempt to create a level whose layout is completely procedurally generated?
									This project set out to test this concept by designing a dungeon crawler where no two playthroughs were the same. 
									The player would navigate a maze-like environment, defeat enemies, collect powerups, and kill the big-bad boss -- all while
									traversing a dynamically generated level. 
									<br>
									<h2>Designing the Level</h2>
									<br>
									This was a student project for a level design class, where we were given a few basic assets, few scripts for enemy AI and camera 
									logic, and a blank state to work with. The goal was not only to crete a level with a clear beginning, middle, and end but also
									to ensure that it was still a fun and engaging experience despite being largely procedurally generated. Most other students opted
									for a design where the player had to traverse from one side of the level to another, as it was much easier to create a difficulty
									curve and clear player progression. But I wanted to challenge myself.
									<br>
									Instead of starting from one side to another, I wanted the player to start in the center of the level. The player could choose 
									any of the four corners of the dungeon, each with a unique biome, distinct enemies, powerups, and a powerful mini-boss. This 
									design added another layer of complexity: the level had to allow the player freedom throughout the entire level while still
									maintaining overall structure, difficulty and progression. The procedural generation needed to make sure that each path was
									navigable, balanced and engaging -- no matter what the procedural generation spat out. 
									<br>
									<br>
									<h2>Corridor Generation</h2>
									<br>
									Generating the pathways was one of the most technically challenging aspects of the project. The corridors had to provide a clear
									flow for the player to follow, allowing them to reach all areas while preserving the feel of well-designed level. Making randomized
									paths would result in either excessive dead ends or a chaotic, nonsensical layout. I needed to strike a balance between randomness
									and structure. So, I developed an algorithm that helped in path creation.
									<br>
									The corridor generation system started from the center room where the player spawns from. Each side of the room had the chance to 
									have a corridor starting tile, which will begin the generation. The tile picks a random direction and starts creating a path. It
									checks if another tile or the world border is in the way for each placement. If an obstacle was found, it would try another direction.
									If that too fails, it backtracks and attempts another path using "branches" -- flags certain tiles have that allow the path to stem 
									from, similar to a tree. This was somewhat inspired from other procedural generation algorithms such as cellular automata and 
									recursive subdivision. The centeral spawn placements acts as a "seed", similar to what is used in cellular automata, making sure
									that the paths organically grow from a specific point. The branching corridors are also similar to recursive subdivision, where 
									the paths were segmented into smaller interconnected paths. I had to ensure none of the paths didn't overlap or connect oddly, 
									such as touching parallel paths. This took extensive tweaking and testing to get right. I never did get it exactly the way I wanted,
									but the challenge alone was an accomplishment.
									<br>
									<br>
									<h3>Note: this is only a small portion of the code!</h3>
									<strong>There is a lot of other checking and boring variable tweaking elsewhere, but we can at least see some basic construction
										with these snippets.
									</strong>
									<br>
									<br>

								<section>
									<h3 class="code-toggle">
										Code Snippets: Corridor Generation
										<img src="images/DropDown.png" alt="Dropdown Icon">
									</h3>
									<pre><code class="language-cpp">
// Spawns a corridor
void GenerateCorridor(int startX, int startY)
{
    // get a starting tile to start a corridor
    SpawnTile(startX, startY);

    // directions for movement (up, down, left, right)
    List<Vector2Int> directions = new List<Vector2Int>
    {
        new Vector2Int(0, 1),  // up
        new Vector2Int(0, -1), // down
        new Vector2Int(-1, 0), // left
        new Vector2Int(1, 0)   // right
    };

    // store x and y values
    int currentX = startX;
    int currentY = startY;

    // store directions
    Vector2Int currentDirection = directions[RNG.Next(directions.Count)];

    // store branch points
    Stack<Vector2Int> branchPoints = new Stack<Vector2Int>();

    bool canPlaceTile = true;
    int attempts = 0; // number of retries when finding a valid direction
    int maxAttempts = 60; // maximum retries before stopping corridor generation

    while (canPlaceTile)
    {
        if (IsValidTilePlacement(currentX, currentY))
        {
            TrySpawnPowerup(currentX, currentY);
            TrySpawnEnemy(currentX, currentY);

            // 80% chance to mark this tile as a branch point
            if (RNG.Next(100) < 80)
                branchPoints.Push(new Vector2Int(currentX, currentY));

            // 0.5% chance to generate a trident-shaped branch
            if (RNG.Next(100) < 0.5 && GenerateTridentBranch(ref currentX, ref currentY, ref currentDirection, branchPoints))
                continue;

            // 50% chance to generate a staircase pattern
            if (RNG.Next(100) < 50 && GenerateStaircasePattern(ref currentX, ref currentY, currentDirection))
                continue;

            // 10% chance to generate a room
            if (RNG.Next(100) < 10 && GetDistanceFromCenter(currentX, currentY) > 15)
            {
                int[] possibleSizes = { 3, 5, 7 };
                PlaceRoom(currentX, currentY, possibleSizes[RNG.Next(possibleSizes.Length)], possibleSizes[RNG.Next(possibleSizes.Length)]);
                continue;
            }

            // 20% chance to change direction
            if (RNG.Next(100) < 20)
            {
                currentDirection = directions[RNG.Next(directions.Count)];

                // 50% chance to generate a spiral
                if (RNG.Next(100) < 50 && GenerateSpiralPattern(ref currentX, ref currentY, ref currentDirection))
                    continue;
            }

            // move in a valid direction or backtrack if stuck
            if (!TryChangeDirection(ref currentX, ref currentY, ref currentDirection, directions, branchPoints, ref attempts, maxAttempts))
                canPlaceTile = false;
        }
        else if (!TryBacktrack(ref currentX, ref currentY, branchPoints, ref currentDirection, directions))
        {
            canPlaceTile = false;
        }
    }
}
									</code></pre>
								</section>

								<section>
									<h3 class="code-toggle">
										Code Snippets: Unique Corridor Generation
										<img src="images/DropDown.png" alt="Dropdown Icon">
									</h3>
									<pre><code class="language-cpp">
// generates a trident branch
bool GenerateTridentBranch(ref int x, ref int y, ref Vector2Int direction, Stack<Vector2Int> branches)
{
	Vector2Int originalBranch = new Vector2Int(x, y);
	Vector2Int initialDirection = direction;

	for (int i = 0; i < 7; i++)
	{
		x += direction.x;
		y += direction.y;
		if (!IsValidTilePlacement(x, y)) return false;
		SpawnTile(x, y);
	}

	branches.Push(originalBranch);
	return true;
}

// generates a staircase pattern
bool GenerateStaircasePattern(ref int x, ref int y, Vector2Int direction)
{
	for (int i = 0; i < 50; i++)
	{
		x += direction.x;
		y += direction.y;
		if (!IsValidTilePlacement(x, y)) return false;
		SpawnTile(x, y);
	}
	return true;
}

// generates a spiral pattern
bool GenerateSpiralPattern(ref int x, ref int y, ref Vector2Int direction)
{
	int[] spiralSteps = { 7, 6, 6, 4, 4, 3, 2 };

	foreach (int steps in spiralSteps)
	{
		for (int i = 0; i < steps; i++)
		{
			x += direction.x;
			y += direction.y;
			if (!IsValidTilePlacement(x, y)) return false;
			SpawnTile(x, y);
		}
		direction = new Vector2Int(-direction.y, direction.x);
	}

	return true;
}
</code></pre>
</section>
									<h2>Overall design</h2>
									<br>
									To make each corner of the dungeon feel distinct, I designed them as unique biomes, each with its own enemy types, powerups, and
									different kinds of corridor designs. The central area inbetween the biomes, which is largely meant to be both a gentle beginning
									and a break inbetween bosses, was relatively neutral. Weaker enemies with little to no power-ups. This was to prepare the player 
									for their adventure -- getting used to combat, learning how enemies act, the controls, etc. It was meant to encourage exploration 
									as well, proding the curiousity of the player to keep going in whatever direction they choose. Additionally, since the player
									could choose any corner to explore first, I designed it so that for every boss killed, the remaining bosses and enemies 
									would get stronger. This helps defeat any linearity, but also ensures that the player is always challenged.
									<br>
									With the little resources I had, I attempted to make each biome have some sort of theme. I attempted to assign enemy types and
									certain pattern generation within the corridors to try and convey this. The black biome, which was home to enemies with a shotgun 
									like spread, had certain corridor patterns that allowed for more open combat. The green biome, which had slow tanky enemies 
									had spiral-like patterns, which allow the player to lose the enemy through line of sight if the player needs to recover. 
									I also attempted to make the power-ups reflect this too! Fast enemies were more likely to drop speed-boosts, while tanks were
									more likely to drop health-boosts. This allowed players to adapt their strategy based on the biome they were in. Tank enemies
									too strong? Go kill some spread enemies for some extra damage! This appraoched helped ensure the procedural generation
									didn't feel too static; every playthrough felt fresh yet still maintained some sort of consistentcy.
									<br>
									Another important aspect of this level design was the gameplay arc -- the pacing and progression of challenges throughout 
									the level. I wanted to implement a false sense of failure for the hook. Players start with a single heart, no powerups, and
									enemies that were stronger than they are. Balanced so delicately, this largely increased their chance of "dying" at this point,
									but still allowed the player to experiment with controls and combat. When they died, they would respawn, keeping any powerups 
									they may have managed to find, and gaining some extra boosts. This was to reinforce the idea that they had to grow stronger to
									progress, a theme carried out further into the level. This safety net of course only lasted for this beginning phase. Once the
									player first "dies", the deaths are permanent, increasing difficulty. This created an engaging difficulty curve. 
									<br>
									<br>
									<section>
										<h3 class="code-toggle">
											Code Snippets: Enemy Buffs
											<img src="images/DropDown.png" alt="Dropdown Icon">
										</h3>
										<pre><code class="language-cpp">
void SetWeaponStats()
{
	WeaponLogic weapon = GetComponentInChildren<WeaponLogic>();
	if (weapon == null) return; // No weapon attached, exit early

	// Set base stats per enemy type
	SetBaseWeaponStats(weapon);

	// Apply buffs based on which bosses have been killed
	ApplyBossBuffs(weapon);
}

// Sets the base weapon stats per enemy type
void SetBaseWeaponStats(WeaponLogic weapon)
{
	switch (enemyType)
	{
		case EnemyType.BaseEnemy:
			weapon.ShotCooldown = 3f;
			weapon.BulletsPerShot = 1;
			weapon.BulletSpreadAngle = 0.0f;
			weapon.BulletRange = 5.0f;
			weapon.BulletSpeed = 3.0f;
			break;

		case EnemyType.FastEnemy:
			weapon.ShotCooldown = 3f;
			weapon.BulletsPerShot = 1;
			weapon.BulletSpreadAngle = 0.0f;
			weapon.BulletRange = 5.0f;
			weapon.BulletSpeed = 6.0f;
			break;

		case EnemyType.SpreadEnemy:
			weapon.ShotCooldown = 6f;
			weapon.BulletsPerShot = 4;
			weapon.BulletSpreadAngle = 25f;
			weapon.BulletRange = 5.0f;
			weapon.BulletSpeed = 5.0f;
			break;

		case EnemyType.TankEnemy:
			weapon.ShotCooldown = 3f;
			weapon.BulletsPerShot = 3;
			weapon.BulletSpreadAngle = 0.0f;
			weapon.BulletRange = 6.0f;
			weapon.BulletSpeed = 2.0f;
			break;

		case EnemyType.UltraEnemy:
			weapon.ShotCooldown = 5f;
			weapon.BulletsPerShot = 5;
			weapon.BulletSpreadAngle = 50f;
			weapon.BulletRange = 20.0f;
			weapon.BulletSpeed = 5.0f;
			break;

		case EnemyType.BossEnemy:
			weapon.ShotCooldown = 3f;
			weapon.BulletsPerShot = 8;
			weapon.BulletSpreadAngle = 40.0f;
			weapon.BulletRange = 100.0f;
			weapon.BulletSpeed = 4.0f;
			break;
	}
}

// Applies boss kill buffs to the weapon and enemy stats
void ApplyBossBuffs(WeaponLogic weapon)
{
	if (!PCGObject.boss1Killed && !PCGObject.boss2Killed && !PCGObject.boss3Killed && !PCGObject.boss4Killed)
		return; // No buffs to apply, exit early

	// List of boss buffs to apply
	(bool bossKilled, ref bool buffApplied, float shotCooldownReduction, int healthIncrease, float speedIncrease,
		float bulletRangeIncrease, float bulletSpeedIncrease, int bulletsPerShotIncrease, float bulletSpreadIncrease, int aggroRangeIncrease)[] bossBuffs =
	{
		(PCGObject.boss1Killed, ref boss1BuffApplied, -0.3f, 1, 0.25f,  0f,   0f,   2,  0f,  0),
		(PCGObject.boss2Killed, ref boss2BuffApplied, -0.3f, 1, 0.25f,  5.0f, 2f,   0,  0f,  0),
		(PCGObject.boss3Killed, ref boss3BuffApplied, -0.3f, 1, 0.25f,  0f,   0f,   0,  5f,  0),
		(PCGObject.boss4Killed, ref boss4BuffApplied, -0.3f, 1, 0.25f,  0f,   0f,   0,  0f,  5)
	};

	foreach (var (bossKilled, buffApplied, cooldownReduction, healthIncrease, speedIncrease, rangeIncrease, speedBoost, bulletsPerShot, spreadIncrease, aggroIncrease) in bossBuffs)
	{
		if (bossKilled && !buffApplied)
		{
			weapon.ShotCooldown += cooldownReduction;
			Health += healthIncrease;
			Speed += speedIncrease;
			weapon.BulletRange += rangeIncrease;
			weapon.BulletSpeed += speedBoost;
			weapon.BulletsPerShot += bulletsPerShot;
			weapon.BulletSpreadAngle += spreadIncrease;
			AggroRange += aggroIncrease;

			buffApplied = true;
		}
	}

	// TankEnemy and UltraEnemy get extra bonuses
	if (enemyType == EnemyType.TankEnemy || enemyType == EnemyType.UltraEnemy)
	{
		foreach (var (bossKilled, buffApplied, cooldownReduction, healthIncrease, speedIncrease, rangeIncrease, speedBoost, bulletsPerShot, spreadIncrease, aggroIncrease) in bossBuffs)
		{
			if (bossKilled && !buffApplied)
			{
				weapon.ShotCooldown += cooldownReduction;
				Health += (enemyType == EnemyType.TankEnemy ? 2 : healthIncrease);
				Speed += speedIncrease;
				weapon.BulletRange += rangeIncrease;
				weapon.BulletSpeed += speedBoost;
				weapon.BulletsPerShot += bulletsPerShot + (enemyType == EnemyType.UltraEnemy ? 1 : 0);
				weapon.BulletSpreadAngle += spreadIncrease;
				AggroRange += (enemyType == EnemyType.TankEnemy ? 7 : aggroIncrease);

				buffApplied = true;
			}
		}
	}
}
	</code></pre>
	</section>
									<h2>Final Thoughts</h2>
									<br>
									This project was a massive learning experience, beyond simply coding procedural generation. It forced me to think critically
									about level design principles, player agency, and balancing procedural content with structured gameplay. I had to guide the player
									without any explicity directions, avoid repitition and predictability, and ensure that the level was both challenging and engaging.
									Through extensive playtesting and iteration, I learned firsthand how procedural generation isn't just about randomness; it is
									about controlled variation. Level design is not simply building a static world, its preparing for every player to experience
									and see things differently.
									<br>
									Overall this project gave me valuable insights into game systems design, algorithmic level generation, and gameplay balancing,
									skills that will, as always, be invaluable in my future projects!
								</p>
							</article>

						<!-- Work 4 -->
							<article id="work4" class="panel">
								<header>
									<h2>Work 4</h2>
								</header>
								<p>
									<!-- Add your content for Work 4 here -->
									This is the content for Work 4.
								</p>
							</article>

						<!-- Blog -->
							<article id="blog" class="panel">
								<header>
									<h2 class="blur-text">Blog<span class="blinking-cursor">|</span></h2>
								</header>
								<section>
									<h3><a href="#blog1">How Getting Hacked Helped Me</a></h3>
									<p>
										Most people are scared of being hacked, yet do nothing to stop it. Or, they believe they won't ever be a target. 
										But what happens when you <i>do</i> get hacked? And how could it be beneficial?
									</p>
								</section>
								<section>
									<h3><a href="#blog2">Blog Post 2</a></h3>
									<p>
										This is the content for Blog Post 2. You can add more details here about your experiences, thoughts, and updates.
									</p>
								</section>
								<section>
									<h3><a href="#blog3">Blog Post 3</a></h3>
									<p>
										This is the content for Blog Post 3. You can add more details here about your experiences, thoughts, and updates.
									</p>
								</section>
								<section>
									<h3><a href="#blog4">Blog Post 4</a></h3>
									<p>
										This is the content for Blog Post 4. You can add more details here about your experiences, thoughts, and updates.
									</p>
								</section>
							</article>

							<!-- Blog Post 1 -->
							<article id="blog1" class="panel">
								<header>
									<h2>How Getting Hacked Helped Me</h2>
								</header>
								<p>
									I work with many people within the tech industry. It is quite literally what I do. But I noticed something odd --
									many people fear getting hacked. The prospect of getting your information stolen, or losing access to your important
									data is something nearly everyone fears. Internet users are always told the same thing: never reuse passwords, never
									give out personal information, be careful what you attach your email to, etc. Yet, nearly everyone I have spoken to,
									despite fearing the idea of being hacked, fails to uphold these general internet safety rules. 
									<br>
									But why?
									<br>
									Sometimes it is out of ignorance, sometimes its out of laziness. I know I was the ladder. I knew of the precautions 
									to take, why they were useful, and why I should listen -- but out of pure laziness, I never stuck to it. Reused
									my passwords for ease of access, used emails to sign up whenever I was prompted without a second thought, etc.
									Since I had no "important" data, and I am just a student, I didn't think I could be a target. I wasn't a millionare
									to get a hacker free money, I didn't hold the secrets to the government, I didn't even have any valuable assets 
									other than some classwork. 
									<br>
									Of course, this doesn't stop people. You don't need to be special to get hacked. Seriously -- it can, and will, 
									happen to anyone at any time. When I got hacked, I was in my third year of college. My computer was chalk full of 
									boring PDFs, class projects, software that were apart of the required curriculum, truly nothing of use to anyone but me.
									I was up at 3:00am working on some coding projects. I had just been invited to work on the 2025 Game Jam with some
									friends. Right as I was finally about to fall asleep, a ping from my Discord rang out. I checked it -- a message
									from one of my friends. They asked if I was willing to playtest their game.
									<br>
									Not only was this during Game Jam, but I have a large circle of other game developers. Asks like this were more
									than common. Naturally, I say yes. I follow through with his request. The "game" doesn't boot. My friend apologizes, 
									says to try again tomorrow. So, I shut down my computer, and hit the hay. It was 
									<br>
									The following morning, I went to open Discord once again on my phone, ready to message my team about the Game Jam. 
									But I was logged out. Odd, sure, but it wouldn't be my first issue with Discord on mobile. A few more login attempts,
									and I can't get in. Now fully awake, I check my computer to log in there -- no luck either.
									<br>
									<br>
									Oh no.
									<br>
									<br>
									I check Microsoft Teams, where I have a message from my friends. They sent a message only moments after I logged off:
									I had been hacked. An account I had used for over 5 years, entirely gone. It was one of my prime forms of communication
									with peers, where I communicated easily between teams, planned projects -- entirely gone. This was the first time I had 
									ever been hacked, but I knew that it was likely that more than just my Discord had been hacked. I immediately checked
									banks, emails, passwords, anything that I thought they may have gotten control of. And unfortunately, I was right.
									It wasn't just Discord. 
									<br>
									Though, it wasn't an entire loss. Quite literally, just days previously, I had found myself researching cybersecurity 
									and privacy online. I tend to scroll endlessly on ranging topics when I have free time, and happened to stumble into the 
									massive web of protecting yourself online. It was fascinating how deeply you could lock yourself down, or how even simple,
									minor changes could protect you more. Reading through had me thinking, "Huh. I'll do that soon. Maybe after midterms." Oh man,
									I was so wrong on how <i>soon</i> that would be. 
									<br>
									Thanks to my reading, I knew it was time to secure myself. Made anonymous emails, uniquely generated passwords, scrubbed
									as much information about myself that I hadn't personally shared off the internet the best I could, encrypted and stored 
									any important information, everything I could think of. It took hours of work. Only by going through <i>everything</i>
									did I realize I wasn't just a student with homework stored on my computer -- it was an encapsulated data pool of everything
									about me. All of my previous, copy-pasted passwords from websites I accessed as a child, to any remnents of legal documentation, 
									to coding projects from middle school all the way to current. 
									<br> 
									I had spent so many years online, it was only natural that so much data would be so easily accessible when I had little to no
									precautions taken. Its shocking how this was the first time I had been hacked, as it would have only taken one wrong person 
									to get access to everything. In one night, had lost so much data. Due to the nature of the hack, I had to wipe my computer.
									I backed up everything I could, but I couldn't save everything. Hours of work to put walls back up, stronger than ever, 
									and more hours put into picking up the pieces of my data that couldn't be saved. It was a shame it required something
									of this measure for me to realize. 
									<br>
									Like it would for anyone, this put me into a pretty bad situation. It threw me off my working schedule with how many hours
									were spent recovering. But, now that I am back on my feet, I don't think the whole situation was all bad. 
									<br>
									<br> 
									You learn from these things when they come at you full force. You have to, afterall. It's a slap in the face once you 
									feel it first hand. Like I said earlier -- no one expects it to be them. But once it is, it completely changes everything. 
									You become aware of how many things track you and your information. How easy it really is to get a password if you try hard
									enough. Your entire perception of safety is changed. You learn what it really takes to be safe. 
									<br> 
									With everything secure again, I feel at peace. It won't ever be perfect, as something you learn quickly is that the more 
									privacy and security you use, the less convenient it is. And as a programmer who uses their computer for hours daily, I 
									must accept my information will never fully be safe. But I will likely never have to deal with this again anytime soon. 
								</p>
							</article>

							<!-- Blog Post 2 -->
							<article id="blog2" class="panel">
								<header>
									<h2>Blog Post 2</h2>
								</header>
								<p>
									This is the detailed content for Blog Post 2. You can add more details here about your experiences, thoughts, and updates.
								</p>
							</article>

							<!-- Blog Post 3 -->
							<article id="blog3" class="panel">
								<header>
									<h2>Blog Post 3</h2>
								</header>
								<p>
									This is the detailed content for Blog Post 3. You can add more details here about your experiences, thoughts, and updates.
								</p>
							</article>

							<!-- Blog Post 4 -->
							<article id="blog4" class="panel">
								<header>
									<h2>Blog Post 4</h2>
								</header>
								<p>
									This is the detailed content for Blog Post 4. You can add more details here about your experiences, thoughts, and updates.
								</p>
							</article>


						<!-- Contact -->
							<article id="contact" class="panel">
								<header>
									<h2 class="blur-text">Contact Me!<span class="blinking-cursor">|</span></h2>
								</header>
								<form action="https://formspree.io/f/mdkakyod" method="post">
									<div>
										<div class="row">
											<div class="col-6 col-12-medium">
												<input type="text" name="name" placeholder="Name" />
											</div>
											<div class="col-6 col-12-medium">
												<input type="email" name="email" placeholder="Email" />
											</div>
											<div class="col-12">
												<input type="text" name="subject" placeholder="Subject" />
											</div>
											<div class="col-12">
												<textarea name="message" placeholder="Message" rows="6"></textarea>
											</div>
											<div class="col-12">
												<input type="submit" value="Send Message" />
											</div>
										</div>
									</div>
								</form>
							</article>

						<!-- About Me -->
							<article id="about-me" class="panel">
								<header>
									<h2 class="blur-text">About Me<span class="blinking-cursor">|</span></h2>
								</header>
								<p>
									<!-- Add your text here -->
									<br>
									<em> "The last frontier is the human mind and we are its pioneers." - Prey 2017 </em>
									<br>
									<br>
									Hello!
									<br>
									<br>
									I am TayLee Young, a third year college student at DigiPen Institute of Technology.
									I am currently studying Computer Science and Game Design. I focus in systems programming, 
									data analysis, and game development. I am proficient in C, C++, C#, and I am learning Python, 
									CSS and HTML. I am also familiar with Unity, Unreal Engine, and Visual Studio.
									<br>
									I have worked on several projects, some of which you can find in the Work section. I have 
									worked teams, big and small, and I have experience in project management and team leadership.
									Of course, I am always looking to expand my knowledge and experience.
									<br>
									<br>
									I am deeply motivated to create games that are more than just entertainment. I want to create
									works of art -- art that inspires people to see things in a new light, to create deeply personal
									and provocative worlds, and to challenge the status quo. I want to not only create games,
									but to create experiences that change people's lives.
									<br>
									I am heavily inspired by games like Prey, Night in the Woods, Journey, Silent Hill,
									and Minecraft. These have impacted my life in ways that I never thought possible. Some 
									inspired my path for game design, others have inspired my deep love and appreciation 
									for the art of creation. I will always remember with fondness the first time I played these games,
									as they have made me who I am today!
									<br>
									<br>
									With every project I am in and every team I am apart of, I push strongly for inclusivity, 
									diversity, and accessibility. I believe that games are for everyone. All people, regardless
									of their background, should experience the joy of this art. As a member of the LGBT+ community,
									I know firsthand the importance of representation, inclusion, and acceptance. No one should 
									feel isolated in their experience. This is my mission and goal. To create games that are for
									everyone, that inspire everyone, and that change everyone.
									<br>
									<br>
									Currently, I am apart of team ADMIS, working on a student project about a corrupt corporation,
									aliens, and a big beefy drill. Feel free to read about that too!
									I am looking for internships and job opportunities, so feel free to contact me anytime!
								</p>
							</article>

					</div>

				<!-- Footer -->
					<div id="footer">
						<ul class="copyright">
							<li>&copy; Portfolio.</li><li>Design: <a href="http://html5up.net">HTML5 UP</a><span class="blinking-cursor">|</span></li>
						</ul>
					</div>

			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>
			<script>
				document.addEventListener('DOMContentLoaded', function() {
					let index = 0;
					const speed = 70; // typing speed in milliseconds
		
					function typeWriter() {
						if (index < text.length) {
							document.getElementById("typed-text").innerHTML += text.charAt(index);
							index++;
							setTimeout(typeWriter, speed);
						}
					}
		
					typeWriter();

					let terminalIndex = 0;

					function typeTerminal() {
						if (terminalIndex < terminalText.length) {
							document.getElementById("terminal-text").innerHTML += terminalText.charAt(terminalIndex) === '\n' ? '<br>' : terminalText.charAt(terminalIndex);
							terminalIndex++;
							setTimeout(typeTerminal, speed);
						}
					}

					typeTerminal();
				});
			</script>
	</body>
</html>	</body>
</html>