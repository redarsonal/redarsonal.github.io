<!DOCTYPE HTML>
<!--
	Astral by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Welcome!</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
		<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/styles/default.min.css">
		<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/highlight.min.js"></script>
	</head>
	<body class="is-preload">
			<div id="black-screen">
				<p id="boot-sequence"></p>
			</div>
		<div class="mouse-light" id="mouse-light"></div>

		<!-- Wrapper-->
			<div id="wrapper">

				<!-- Nav -->
					<nav id="nav">
						<a href="#">Home</a>
						<a href="#work">Work</a>
						<a href="#contact">Contact</a>
						<a href="#about-me">Me</a>
					</nav>

				<!-- Main -->
					<div id="main">

						<!-- Me -->
							<article id="home" class="panel intro">
								<header>
									<h1 class="blur-text">TayLee Young<span class="blinking-cursor">|</span></h1>
											<p>Systems Programmer and Game Designer</p>
										<!--<img src="images/me.jpg" alt="" /> -->
										<!-- ASCII Art Container -->
										<pre id="ascii-art-container"></pre>
								</header>
							</article>

						<!-- Work -->
							<article id="work" class="panel">
								<header>
									<h2 class="blur-text">Featured Work<span class="blinking-cursor">|</span></h2>
								</header>
								<p>
									Here is some of my most recent work! Some are still in production, some are finished.
									This work showcases my skills in programming, game design, and systems. If you would to take a peek at my
									resume, you can find it here, or over in my about me page. 
									<br>
									<br>
									<!-- Projects that I have lost access to their original source code, as well as commentary
									on my experiences in this field can be found within the <a href="#blog">Blog</a> section, so feel free to 
									check that out as well! -->
									I will be adding a blog section soon, which covers some other projects I have worked on, as well as my
									thoughts on other related technological topics, so stay tuned for that!
								</p>
								<section>
									<div class="row">
										<div class="col-12">
											<figure>
												<a href="#work1" class="image fit"><img src="images/pic04.jpg" alt=""></a>
												<figcaption><i>SHUTTLEFALL</i></figcaption>
												<figcaption> Aliens, corrupt business practices, and a <i>massive</i> drill.</figcaption>
											</figure>
										</div>
										<div class="col-12">
											<figure>
												<a href="#work2" class="image fit"><img src="images/mothTitleScreen.gif" alt=""></a>
												<figcaption><i>Moth 2: The Mothening</i></figcaption>
												<figcaption>From fluttering wings to fortune -- grow your moth empire!</figcaption>
											</figure>
										</div>
										<div class="col-12">
											<figure>
												<a href="#work3" class="image fit"><img src="images/refractionTitleScreen.gif" alt=""></a>
												<figcaption><i>Refraction</i></figcaption>
												<figcaption>A custom engine running CPU-based pixel-by-pixel light calculations? 
													How hard can that be?
												</figcaption>
											</figure>
										</div>
										<div class="col-12">
											<figure>
												<a href="#work4" class="image fit"><img src="images/PDthumbnail.png" alt=""></a>
												<figcaption><i>Procedurally Generated Dungeon</i></figcaption>
												<figcaption>What happens when you try to design a playable level using
													entirely procedurally generated layouts?
												</figcaption>
											</figure>
										</div>
									</div>
								</section>
							</article>

							<style>
								figure {
									margin-bottom: 10rem;
								}
							
								figcaption {
									margin-top: 0.5rem;
									text-align: center;
								}
							</style>

						<!-- Work 1 -->
							<article id="work2" class="panel">
								<header>
									<h2><i>Moth 2: The Mothening</i></h2>
								</header>
								<p>
									On an alien planet, moths grow to be 5x the size of the ones we find on Earth. They are cute, cuddly, and worth quite the price. You set up a base on this planet, creating a greenhouse as your base of operations. Alone on the planet, you seek to catch, breed, and sell moths all to become a monopoly. 
									<br>
									It's hard to sell these guys with how cute they are though...
									<br>
									<h2> Title 1 </h2>
									This project was one of the first major scale projects I had been a part of. It was the first time I worked on such a large team consisting of different disciplines, the first time I was able to work on a GAM project using Unreal Engine 5, let alone any commercial engine. The project was a massive learning experience for me, yet one of my favorite projects to date. I've been in leadership positions before, but not quite of this magnitude. I was the Technical Advocate (or Technical Lead, or 
 the "manager of the programmers"), and I was also the main systems designer. Considering this project was heavily systems-focused, I had a lot of work to do.
									<br>
									<h2> Title 2 </h2>
									My main goal was to design the Market, a massive computer sitting in the greenhouse. The player could catch or breed moths and sell them here, where the main point was to get as much money and monopolize the moth market. On the outside, it seemed simple -- take the moth, look up a price, and sell it for said price. However, we wanted to be unique. Since this game initially started as an economy simulator, we decided to put a little more thought into it. The breakdown of how a <i>single</i> moth's value gets calculated is as follows
									<br>
									<br>
									<ol>
										<li>Check if the moth is wild-caught or bred. Wild-caught moths sell for slightly less.</li>
										<li> We need both the species and that specific moth's quality next -- the most important factors
											in determining a base price.
										</li>
										<li>Taking the species, we can add certain modifiers to get the proper ratio of quality to sell price. This is important as rarely does a species have a simple exponential path -- most are logarithmic, sine, or even a little bit linear. This gives the player a reason to find what species are worth more
											at different qualities.
										</li>
										<li>Of course, this means we also must check the quality. From 1-100, we group the qualities into 
											subcategories, some rarer than others. Breeding or being lucky while outside can get you a higher quality -- which of course, typically means more money as well.
										</li>
									</ol> 
									<br>
									It gets a little more in-depth than all that, but that's the overview. While I worked on this nearly entirely by myself, I still got some great help from our designers and other programmers to help me
 test and try new methods to get it just right.
									<br>
									While working on this major mechanic, it was my job to ensure that the rest of the programmers had clear goals. I worked with each one personally, making sure that each one had the resources they needed, knew what they had to do, and whenever possible, worked on tasks that they were most compatible with. We had a programmer fitting for most tasks -- UI/UX, tools, AI, gameplay, etc. I had to ensure that they were comfortable both in their tasks themselves, and their respective workloads. Communication 
was key to everything I did. Using a multitude of tools, such as Trello, Discord, When2Meet, and Teams, I could ensure that everyone had all the resources to communicate. Fleshed out documentation for the 
game itself aided in this as well.
									<br>
									<h2> Title 3 </h2>
									Of course, nothing was all perfect, even beyond bugs and crashes. Conflicts between teammates, especially when it came to design choices, were common. This often meant that I had to help handle the situation or guide the conversation to a productive end. If the programmers felt like the deadlines being requested of them from the producer were too tight or unrealistic, I mediated that conversation as well, pushing to come to a compromise that doesn't overwhelm the programmers, yet ensures we were still on track for our milestones.
									<br>
									Additionally, as is the nature of programming, both my pride and joy in the market and the other
 systems I had a hand in, were not without their issues either. The market went through several iterations, causing me to delay and rework time and time again. Since the three core mechanics of catching, breeding, and selling were so interconnected, this also meant a lot of back-and-forth
 handling. Reworking or changing one mechanic often leads to a cascade of changes in the other two. While we often warned the designers and producers, we ultimately had many 
 issues with a constantly changing game -- to the point that the very market I put so much time into was nearly entirely scrapped, being reworked into a much different system. The bane of every software developer. 
									<br>
									<h2> Title 4 </h2>
									In the end, the project has been an incredible experience. While every project that I have worked on -- big or small -- always lets me expand my knowledge and experiment, this project is arguably the most relevant to me. It was the first time I was able to work on a project with such important roles, and it was also the definitive reason I enjoyed systems programming. I had an interest in it before but had yet to dive into it. This project was the perfect opportunity to do so, and I ran with it. With how interconnected and complex every system was, I was able to learn so much about how to design, implement, and maintain systems while balancing my other tasks as well. My leadership skills have also improved -- while it wasn't the first time I had taken a role similar to it, this pushed what I already knew and proved there is always time for improvement. 
								</p>
							</article>

						<!-- Work 2 -->
							<article id="work3" class="panel">
								<header>
									<h1><i>Refraction</i></h1>
								</header>
								<p>
									You find yourself lost in the depths of a dungeon. It's dark, damp, and cramped.
									Equipped with a solitary light, you venture forward, discovering large crystals
									that can shift and redirect light beams. Soon, it dawns on you — manipulating 
									these beams unlocks pathways, each puzzle leading closer to an escape.
									<br>
									This was the core concept of a game my team and I developed during our second
									year of college at DigiPen Institute of Technology. The game was called Refraction,
									a nod to the lighting mechanic that was the core of the game. The game spanned a 
									full academic year, and the game was created entirely in a custom-made engine.
									As the engine programmer, I was responsible for building the engine from the ground
									up using a limited toolkit: JSON, SDL2, ImGui, and OpenGL. With just a year of programming
									experience — and even less in C++ — this role was both a challenge and a major
									opportunity for growth.
									<br>
									<h2>Building the Engine</h2>
									<br>
									The first hurdle was getting the engine up and running within a tight time constraint.
									We needed a functional prototype as quickly as possible to support the rest of the team. 
									I knew that I needed to build a solid foundation that could be expanded upon later, especially
									for the lighting systems that would be created by our graphics programmer. I leaned heavily
									on preventative measures: designing the code to handle potential errors gracefully and 
									implementing safe coding practices. While the initial steps of creating a custom engine were
									daunting, I managed to produce a basic framework in just two weeks. This framework included
									input handling, scene management, level loading, basic rendering, debugging tools, and anything
									else I could think of that would be useful for the team.
									<br>
									Working on the engine gave me a newfound appreciation for aspects of game development that
									are often invisible to end users. Creating features like scene transitions and level 
									management from scratch revealed the intricacies involved and the importance of a solid
									foundation. In addition, there were countless design choices I had to weigh in on. What engine
									design pattern should I choose? Observer? Composite? Singleton? There was so much to consider,
									but I opted for the singleton pattern due to its simplicity and ease of use. This was just one of
									many decisions that would shape the engine's architecture and the game's development.
									As someone who previously took these systems for granted when using professional
									engines, this was an eye-opening experience.
									<br>
									<br>
									<!-- New Code Snippets Section -->
									<section>
										<h3 class="code-toggle">
											Code Snippets: Simple Engine Implementation
											<img src="images/DropDown.png" alt="Dropdown Icon">
										</h3>
										<pre><code class="language-cpp">
// singleton instance
Engine* Engine::instance = new Engine();

Engine::EngineCode Engine::Start()
{
	// time instance
	time = new Time();

	AudioManager.LoadMusicFromJSON("./Data/music.json");
	AudioManager.LoadSFXFromJSON("./Data/SFX.json");
	// initalize all systems
	for (int i = 0; i < systemCount; ++i)
	{
		try
		{
			systems[i]->Init();
		}
		catch (EngineCode engineFailure)
		{
			assert(engineFailure && "Engine failed to initialize. Location: Engine::Start(), Init()");
			return engineFailure;
		}
	}

	// main game loop
	while (isRunning && !closeRequested)
	{
		EngineCode code = NothingBad;

		try
		{
			code = Update();
		}
		catch (EngineCode updateFailure)
		{
			assert(updateFailure && "Engine failed during update. Location: Engine::Start(), Update()");
			return updateFailure;
		}
		if (code == CloseWindow)
			break;

		try
		{
			code = Render();
		}
		catch (EngineCode renderFailure)
		{
			assert(renderFailure && "Engine failed during render. Location: Engine::Start(), Render()");
			return renderFailure;
		}
		if (code == CloseWindow)
			break;
	}

	// stop engine
	return Stop();
}

Engine::EngineCode Engine::Stop()
{
	try
	{
		ShutDown();
	}
	catch (EngineCode shutdown)
	{
		assert(shutdown && "Engine failed to shut down. Location: Engine::Stop(), ShutDown()");
		return shutdown;
	}

	return EngineExit;
}

void Engine::EngineAddSystem(BaseSystem* sys)
{
	systems[systemCount++] = sys;
}

bool Engine::Paused()
{
	return paused;
}

void Engine::SetPause(bool pause)
{
	paused = pause;
}

// get the singleton instance
Engine* Engine::GetInstance()
{
	if (instance == nullptr)
	{
		instance = new Engine();
	}
	return instance;
}

Engine::Engine() : isRunning(true), systemCount(0), systems(), paused(false), time(NULL), closeRequested(false)
{
}

Engine::~Engine()
{
	if (instance != NULL)
	{
		delete instance;
	}
}

Engine::EngineCode Engine::Update()
{
	float dt = Time::Instance().Delta();

	// update all systems
	for (int i = 0; i < systemCount; ++i)
	{
		try {
			systems[i]->Update(dt);
		}
		catch (EngineCode updateFailure)
		{
			switch (updateFailure)
			{
			case CloseWindow:
				return updateFailure;
			default:
				assert(updateFailure && "Engine failed during system update. Location: Engine::Update()");
				throw(updateFailure);
			}
		}
	}
	return NothingBad;
}

Engine::EngineCode Engine::Render()
{
	// render all systems
	for (int i = systemCount; ++i)
	{
		systems[i]->Render();
	}
	return NothingBad;
}

Engine::EngineCode Engine::ShutDown()
{
	// close all systems
	for (int i = systemCount - 1; i >= 0; --i)
	{
		systems[i]->Close();
	}

	delete time;
	AudioManager.Free();
	return EngineExit;
}

// set flag to close game engine for whatever reasons you want
void Engine::SetCloseRequest(bool close)
{
	closeRequested = close;
}
										</code></pre>
									</section>
									<h2>Optimizing Performance</h2>
									<br>
									One of the most significant challenges we faced was performance optimization. Our game 
									initially struggled to maintain even 30 FPS. Given my familiarity with the engine, I took 
									the lead in diagnosing bottlenecks. This required diving into the graphics programmer's code,
									experimenting with Visual Studio's Profiler, and creating ImGui tools to track performance metrics
									in real time.
									<br>
									A key decision was made right before this optimization phase: our graphics programmer wanted to
									perform lighting calculations on the CPU rather than the GPU. The lighting system relied on pixel-by-pixel
									math calculations, and using the CPU allowed the graphics programmer to maintain precise control over each
									individual pixel. While this method offered flexibility and allowed for the unique lighting effect we sought
									to create, it came at the cost of significant performance overhead. GPUs are designed for parallel processing
									and would typically be far more efficient for this type of computation. However, at the time, our team prioritized
									the control and simplicity of the CPU-based approach. We wanted to test the boundaries of what we could do, and
									although this decision contributed to the challenges we faced in maintaining stability and performance, it also 
									allowed us to create a unique and visually striking game. 
									<br>
									While I made some improvements, my limited experience meant there were persistent inefficiencies. Despite my best 
									efforts, we couldn't fully address all performance issues within the project's timeline. This was a tough lesson:
									foundational code quality and ongoing maintenance are crucial for long-term success. Our struggles reinforced
									the importance of clean, maintainable code, and proactive profiling —— lessons that I've carried into every project since.
									<br>
									<br>
									<div class="gallery">
										<a href="#pic05" class="thumbnail"><img src="images/refractiondemo.gif" alt="Example of lighting and gameplay."></a>
									</div>
									<br>
									<br>
									<h2>Developing an Editor</h2>
									<br>
									With the engine stable enough for continuing production, I took on the task of developing a level editor to streamline
									the designers' workflow. Using ImGui, I built an interface that allowed designers to add and remove entities, import 
									layouts from their planning tools, and adjust properties dynamically. This task required me to dive deep into 
									ImGui's documentation and address compatibility challenges with our engine's OpenGL and SDL2 setup. The process was 
									slow at first, but the final editor significantly improved the team's efficiency. 
									<br>
									Beyond the core editor functionality, I added debugging tools to track entities and their statistics, tracking and allowing
									dynamic modification of particles, dynamic adjustments of lights, display lighting properties, level importing and saving
									from JSON, etc. These tools weren't just useful; they were essential for diagnosing issues during the final stages 
									of development. While the editor wasn't perfect, it marked a major milestone in my understanding of tool development 
									and user-focused design. This process was one of the most difficult, as the documentation was loaded with information
									I had to sort through, and the process of creating the editor was a trial-and-error process. The other programmers were
									essential to get this task done in time, and I am grateful for their help.
									<br>
									<br>
																	<!-- Code Snippets Section -->
								<section>
									<h3 class="code-toggle">
										Code Snippets: Entity Creation in Editor
										<img src="images/DropDown.png" alt="Dropdown Icon">
									</h3>
									<pre><code class="language-cpp">
int LevelCreatorScene::CreateCircleEntity()
{
	int circles_existing = 0;
	std::string number = "./Data/GameObjects/Circle";
	std::string filename = "./Data/GameObjects/Circle.json";

	Entity* temp = FileIO::GetInstance()->ReadEntity(filename);

	temp->addKey = "Circle";

	temp->key = "Circle" + std::to_string(circleCount);
	tempEntities.push_back(temp);
	++circleCount;
	return 0;
}

int LevelCreatorScene::CreateDoorEntity()
{
	int door_existing = 0;
	std::string number = "./Data/GameObjects/Door";
	std::string filename = "./Data/GameObjects/Door.json";

	Entity* temp = FileIO::GetInstance()->ReadEntity(filename);

	temp->addKey = "Door"; 

	temp->key = "Door" + std::to_string(doorCount);

	tempEntities.push_back(temp);
	++doorCount;
	return 0;
}

int LevelCreatorScene::CreateMirrorEntity(MirrorData mirror)
{
	int door_existing = 0;

	UNREFERENCED_PARAMETER(door_existing);

	std::string number = "./Data/GameObjects/Mirror";

	std::string filename;
	switch (mirror.spriteDirection) {
	case 1: filename = "./Data/GameObjects/MirrorTopLeft.json"; break;
	case 2: filename = "./Data/GameObjects/MirrorTopRight.json"; break;
	case 3: filename = "./Data/GameObjects/MirrorBottomLeft.json"; break;
	case 4: filename = "./Data/GameObjects/MirrorBottomRight.json"; break;
	default: return 0;
	}

	//classic naming conventions
	Entity* temp = FileIO::GetInstance()->ReadEntity(filename);
	temp->GetComponent<BehaviorMirror>()->SetReflection(mirror.direction);

	temp->addKey = "Mirror"; // this is for the map holding functions and gives access to function for circle

	temp->key = "Mirror" + std::to_string(mirrorCount);

	tempEntities.push_back(temp);
	++mirrorCount;
	return 0;
}

int LevelCreatorScene::CreateEmitterEntity(EmitterData emit)
{
	std::string number = "./Data/GameObjects/Emitter";
	std::string filename = "./Data/GameObjects/tempEmitter.json";

	Entity* temp = FileIO::GetInstance()->ReadEntity(filename);

	switch (emit.spriteDirection) {
	case 1:
	{
		BehaviorEmitter* mine = temp->GetComponent<BehaviorEmitter>();
		mine->SetDirection({ 0.0f, -1.0f });
		mine->SetPosition(*temp->GetComponent<Transform>()->GetTranslation());
		break;
	}
	case 2:
	{
		BehaviorEmitter* mine = temp->GetComponent<BehaviorEmitter>();
		mine->SetPosition(*temp->GetComponent<Transform>()->GetTranslation());
		mine->SetDirection({ 0.0f, 1.0f });
		break;
	}
	case 3:
	{
		BehaviorEmitter* mine = temp->GetComponent<BehaviorEmitter>();
		mine->SetDirection({ 1.0f, 0.0f });
		mine->SetPosition(*temp->GetComponent<Transform>()->GetTranslation());
		break;
	}
	case 4:
	{
		BehaviorEmitter* mine = temp->GetComponent<BehaviorEmitter>();
		mine->SetDirection({ -1.0f, 0.0f });
		mine->SetPosition(*temp->GetComponent<Transform>()->GetTranslation());
		break;
	}
	default: return 0;
	}
	temp->addKey = "Emitter"; // this is for the map holding functions and gives access to function for circle

	temp->key = "Emitter" + std::to_string(emitterCount);

	tempEntities.push_back(temp);
	++emitterCount;
	return 0;
}
									</code></pre>
								</section>
								<!-- New Code Snippets Section -->
								<section>
									<h3 class="code-toggle">
										Code Snippets: Scene Settings
										<img src="images/DropDown.png" alt="Dropdown Icon">
									</h3>
									<pre><code class="language-cpp">
ImGui::Text("Scene Settings");
ImGui::Text("./Data/Scenes/''LevelNameHere''");
if (ImGui::TreeNode("Export:"))
{
	ImGui::Text("TileMapOnly");
	ImGui::InputText(".json", myTextBuffer, sizeof(myTextBuffer));
	if (ImGui::Button("ExportTileMap"))
	{
		std::string exportFileName = std::string(myTextBuffer);
		if (exportFileName.empty())
		{
			ImGui::OpenPopup("EmptyExportFileNamePopup");
		}
		else if (!IsFileNameValid(exportFileName))
		{
			ImGui::OpenPopup("InvalidExportFileNamePopup");
		}
		else
		{
			FileIO::GetInstance()->ExportTileMap(myTextBuffer);
			ImGui::OpenPopup("SuccessfulExport");
		}
	}

	if (ImGui::Button("ExportFullScene"))
	{
		std::string exportFileName = std::string(myTextBuffer);
		if (exportFileName.empty())
		{
			ImGui::OpenPopup("EmptyExportFileNamePopup");
		}
		else if (!IsFileNameValid(exportFileName))
		{
			ImGui::OpenPopup("InvalidExportFileNamePopup");
		}
		else
		{
			ExportScene(myTextBuffer);
			ImGui::OpenPopup("SuccessfulExport");
		}
	}

	ImGuiManager::RenderOKPopup("SuccessfulExport", "Exported!");
	ImGuiManager::RenderOKPopup("EmptyExportFileNamePopup", "Please provide a file name for export!");
	ImGuiManager::RenderOKPopup("InvalidExportFileNamePopup", "Illegal characters in the tilemap name GOOBER!");

	ImGui::TreePop();
}

if (ImGui::TreeNode("Import:"))
{
	static char filenameBuffer[256];
	ImGui::InputText(".json", filenameBuffer, sizeof(filenameBuffer));

	ImGui::Text("NOTE: this will reset the current level.");
	{
		if (ImGui::Button("Submit"))
		{
			std::string filename = "./Data/Scenes/" + std::string(filenameBuffer) + ".json";

			if (std::string(filenameBuffer).empty())
			{
				ImGui::OpenPopup("EmptyImportFileNamePopup");
			}
			else if (!IsFileNameValid(filenameBuffer))
			{
				ImGui::OpenPopup("InvalidImportFileNamePopup");
			}
			else
			{
				std::ifstream file(filename);
				sceneName = std::string(filenameBuffer);
				if (file.is_open())
				{
					file.close();
					Renderer::GetInstance()->CleanRenderer();
					LevelBuilder::GetInstance()->LoadTileMap(filename);
					if (EntityContainer::GetInstance()->CountEntities() > 0)
					{
						int size = EntityContainer::GetInstance()->CountEntities();
						for (int i = 0; i < size; ++i)
						{
							if ((*EntityContainer::GetInstance())[i])
							{
								tempEntities.push_back((*EntityContainer::GetInstance())[i]);
								tempEntities[i]->addKey = tempEntities[i]->GetRealName();
								if (tempEntities[i]->GetRealName().compare("Player") == 0)
								{
									playerExists = true;
								}
							}
						}
					}
					json counts = FileIO::GetInstance()->OpenJSON("./Data/Scenes/" + std::string(filenameBuffer) + "OBJECTS.json");

					if (counts["Circle"].is_object())
					{
						circleCount = counts["Circle"]["count"];
					}
					if (counts["Door"].is_object())
					{
						doorCount = counts["Door"]["count"];
					}
					if (counts["Mirror"].is_object())
					{
						mirrorCount = counts["Mirror"]["count"];
					}
					if (counts["Emitter"].is_object())
					{
						emitterCount = counts["Emitter"]["count"];
					}
					if (counts["Receiver"].is_object())
					{
						ReceiverCount = counts["Receiver"]["count"];
					}

					if (!entityManager->InitializeProperties(filename + "OBJECTS.json"))
					{
						ImGui::OpenPopup("NoObjectsInScene");
					}

					ImGui::OpenPopup("SuccessfulImport");
				}
				else
				{
					ImGui::OpenPopup("FileNotFoundPopup");
				}
			}
		}

		ImGuiManager::RenderOKPopup("SuccessfulImport", "Successfully imported the scene!");

		ImGuiManager::RenderOKPopup("NoObjectsInScene", "Objects do not exist in this scene.");

		ImGuiManager::RenderOKPopup("EmptyImportFileNamePopup", "Please provide a file name for import!");

		ImGuiManager::RenderOKPopup("InvalidImportFileNamePopup", "Please provide a valid file name without illegal characters for import!");

		ImGuiManager::RenderOKPopup("InvalidImportFileNamePopup", "Please provide a valid file name without illegal characters for import!");

		ImGuiManager::RenderOKPopup("FileNotFoundPopup", "File not found!");
	}
	ImGui::TreePop();
}
									</code></pre>
								</section>
									<h2>Final Touches And Lessons</h2>
									<br> As time came to an end, I wrapped up the engine with some final touches to ensure everything was stable 
									and performed as we expected. I aided the graphics programmer in creating the menus —— another hand-made visual
									that tied together our stylization. And with that, we were done.
									<br>
									This project was a crucible of learning experiences:
									<br>Engine Architecture - Designing the engine entirely myself taught me how critical it is to align 
									architecture with project requirements. The decision to use a singleton pattern, while simple and effective for a 
									student project, highlighted the trade-offs inherent in design decisions.
									<br>Performance Optimization - Profiling tools and debugging performance bottlenecks were
									invaluable skills I developed. I learned that optimization is as much about identifying problems as it is about
									knowing when to prioritize other tasks. 
									<br>Collaboration - While working in a small team led to more collaboration and effective communication,
									it also required me to take on multiple roles. I learned to balance my responsibilities and communicate effectively with
									what was needed for the project. This was also one of the first projects where I had to work in parallel with other programmers.
									It reinforced how important it was to provide clear documentation, maintain consistent and clean code, and communicate
									regularly with the team.
									<br>Iterative Development - The necessity of balancing feature development with performance and usability 
									underscored the iterative nature of game development. As stated before, starting with and maintaining clean, well-documented 
									code is far easier than fixing problems either. Additionally, especially when it came to tool and engine development, I often
									had to go back and revise my work to accommodate new features or changes. This was a lesson in flexibility and adaptability.
									<br>
									<br>
									<h2>The Final Product</h2>
									<br>
									In the end, our team produced a functional, engaging puzzle game with dynamic lighting, handcrafted visuals, and satisfying
									gameplay. The experience taught me as much about teamwork and project management as it did about technical skills.
									From handling conflicts in code and within the team to finding creative solutions under pressure, this project laid the
									foundation for my future growth as a developer. 
									<br>
									To this day, I'm grateful for the challenges and lessons of this project. It wasn't perfect — far from it — but it
									was a pivotal experience in my journey as a programmer and game designer. The experience reinforced my passion for game 
									development and systems programming, and I carry the lessons with every project!

								</p>
							</article>

						<!-- Work 3 -->
							<article id="work4" class="panel">
								<header>
									<h2>Procedurally Generated Dungeon</h2>
								</header>
								<p>
									What happens, as a game developer, when you attempt to create a level whose layout is completely procedurally generated?
									This project set out to test this concept by designing a dungeon crawler where no two playthroughs were the same. 
									The player would navigate a maze-like environment, defeat enemies, collect powerups, and kill the big-bad boss -- all while
									traversing a dynamically generated level. 
									<br>
									<h2>Designing the Level</h2>
									<br>
									This was a student project for a level design class, where we were given a few basic assets, few scripts for enemy AI and camera 
									logic, and a blank state to work with. The goal was not only to crete a level with a clear beginning, middle, and end but also
									to ensure that it was still a fun and engaging experience despite being largely procedurally generated. Most other students opted
									for a design where the player had to traverse from one side of the level to another, as it was much easier to create a difficulty
									curve and clear player progression. But I wanted to challenge myself.
									<br>
									Instead of starting from one side to another, I wanted the player to start in the center of the level. The player could choose 
									any of the four corners of the dungeon, each with a unique biome, distinct enemies, powerups, and a powerful mini-boss. This 
									design added another layer of complexity: the level had to allow the player freedom throughout the entire level while still
									maintaining overall structure, difficulty and progression. The procedural generation needed to make sure that each path was
									navigable, balanced and engaging -- no matter what the procedural generation spat out. 
									<br>
									<br>
									<h2>Corridor Generation</h2>
									<br>
									Generating the pathways was one of the most technically challenging aspects of the project. The corridors had to provide a clear
									flow for the player to follow, allowing them to reach all areas while preserving the feel of well-designed level. Making randomized
									paths would result in either excessive dead ends or a chaotic, nonsensical layout. I needed to strike a balance between randomness
									and structure. So, I developed an algorithm that helped in path creation.
									<br>
									The corridor generation system started from the center room where the player spawns from. Each side of the room had the chance to 
									have a corridor starting tile, which will begin the generation. The tile picks a random direction and starts creating a path. It
									checks if another tile or the world border is in the way for each placement. If an obstacle was found, it would try another direction.
									If that too fails, it backtracks and attempts another path using "branches" -- flags certain tiles have that allow the path to stem 
									from, similar to a tree. This was somewhat inspired from other procedural generation algorithms such as cellular automata and 
									recursive subdivision. The centeral spawn placements acts as a "seed", similar to what is used in cellular automata, making sure
									that the paths organically grow from a specific point. The branching corridors are also similar to recursive subdivision, where 
									the paths were segmented into smaller interconnected paths. I had to ensure none of the paths didn't overlap or connect oddly, 
									such as touching parallel paths. This took extensive tweaking and testing to get right. I never did get it exactly the way I wanted,
									but the challenge alone was an accomplishment.
									<br>
									<br>
									<h3>Note: this is only a small portion of the code!</h3>
									There is a lot of other checking and boring variable tweaking elsewhere, but we can at least see some basic construction
										with these snippets.
									
									<br>
									<br>

								<section>
									<h3 class="code-toggle">
										Code Snippets: Corridor Generation
										<img src="images/DropDown.png" alt="Dropdown Icon">
									</h3>
									<pre><code class="language-cpp">
// Spawns a corridor
void GenerateCorridor(int startX, int startY)
{
    // get a starting tile to start a corridor
    SpawnTile(startX, startY);

    // directions for movement (up, down, left, right)
    List<Vector2Int> directions = new List<Vector2Int>
    {
        new Vector2Int(0, 1),  // up
        new Vector2Int(0, -1), // down
        new Vector2Int(-1, 0), // left
        new Vector2Int(1, 0)   // right
    };

    // store x and y values
    int currentX = startX;
    int currentY = startY;

    // store directions
    Vector2Int currentDirection = directions[RNG.Next(directions.Count)];

    // store branch points
    Stack<Vector2Int> branchPoints = new Stack<Vector2Int>();

    bool canPlaceTile = true;
    int attempts = 0; // number of retries when finding a valid direction
    int maxAttempts = 60; // maximum retries before stopping corridor generation

    while (canPlaceTile)
    {
        if (IsValidTilePlacement(currentX, currentY))
        {
            TrySpawnPowerup(currentX, currentY);
            TrySpawnEnemy(currentX, currentY);

            // 80% chance to mark this tile as a branch point
            if (RNG.Next(100) < 80)
                branchPoints.Push(new Vector2Int(currentX, currentY));

            // 0.5% chance to generate a trident-shaped branch
            if (RNG.Next(100) < 0.5 && GenerateTridentBranch(ref currentX, ref currentY, ref currentDirection, branchPoints))
                continue;

            // 50% chance to generate a staircase pattern
            if (RNG.Next(100) < 50 && GenerateStaircasePattern(ref currentX, ref currentY, currentDirection))
                continue;

            // 10% chance to generate a room
            if (RNG.Next(100) < 10 && GetDistanceFromCenter(currentX, currentY) > 15)
            {
                int[] possibleSizes = { 3, 5, 7 };
                PlaceRoom(currentX, currentY, possibleSizes[RNG.Next(possibleSizes.Length)], possibleSizes[RNG.Next(possibleSizes.Length)]);
                continue;
            }

            // 20% chance to change direction
            if (RNG.Next(100) < 20)
            {
                currentDirection = directions[RNG.Next(directions.Count)];

                // 50% chance to generate a spiral
                if (RNG.Next(100) < 50 && GenerateSpiralPattern(ref currentX, ref currentY, ref currentDirection))
                    continue;
            }

            // move in a valid direction or backtrack if stuck
            if (!TryChangeDirection(ref currentX, ref currentY, ref currentDirection, directions, branchPoints, ref attempts, maxAttempts))
                canPlaceTile = false;
        }
        else if (!TryBacktrack(ref currentX, ref currentY, branchPoints, ref currentDirection, directions))
        {
            canPlaceTile = false;
        }
    }
}
									</code></pre>
								</section>

								<section>
									<h3 class="code-toggle">
										Code Snippets: Unique Corridor Generation
										<img src="images/DropDown.png" alt="Dropdown Icon">
									</h3>
									<pre><code class="language-cpp">
// generates a trident branch
bool GenerateTridentBranch(ref int x, ref int y, ref Vector2Int direction, Stack<Vector2Int> branches)
{
	Vector2Int originalBranch = new Vector2Int(x, y);
	Vector2Int initialDirection = direction;

	for (int i = 0; i < 7; i++)
	{
		x += direction.x;
		y += direction.y;
		if (!IsValidTilePlacement(x, y)) return false;
		SpawnTile(x, y);
	}

	branches.Push(originalBranch);
	return true;
}

// generates a staircase pattern
bool GenerateStaircasePattern(ref int x, ref int y, Vector2Int direction)
{
	for (int i = 0; i < 50; i++)
	{
		x += direction.x;
		y += direction.y;
		if (!IsValidTilePlacement(x, y)) return false;
		SpawnTile(x, y);
	}
	return true;
}

// generates a spiral pattern
bool GenerateSpiralPattern(ref int x, ref int y, ref Vector2Int direction)
{
	int[] spiralSteps = { 7, 6, 6, 4, 4, 3, 2 };

	foreach (int steps in spiralSteps)
	{
		for (int i = 0; i < steps; i++)
		{
			x += direction.x;
			y += direction.y;
			if (!IsValidTilePlacement(x, y)) return false;
			SpawnTile(x, y);
		}
		direction = new Vector2Int(-direction.y, direction.x);
	}

	return true;
}
</code></pre>
</section>
									<h2>Overall design</h2>
									<br>
									To make each corner of the dungeon feel distinct, I designed them as unique biomes, each with its own enemy types, powerups, and
									different kinds of corridor designs. The central area inbetween the biomes, which is largely meant to be both a gentle beginning
									and a break inbetween bosses, was relatively neutral. Weaker enemies with little to no power-ups. This was to prepare the player 
									for their adventure -- getting used to combat, learning how enemies act, the controls, etc. It was meant to encourage exploration 
									as well, proding the curiousity of the player to keep going in whatever direction they choose. Additionally, since the player
									could choose any corner to explore first, I designed it so that for every boss killed, the remaining bosses and enemies 
									would get stronger. This helps defeat any linearity, but also ensures that the player is always challenged.
									<br>
									With the little resources I had, I attempted to make each biome have some sort of theme. I attempted to assign enemy types and
									certain pattern generation within the corridors to try and convey this. The black biome, which was home to enemies with a shotgun 
									like spread, had certain corridor patterns that allowed for more open combat. The green biome, which had slow tanky enemies 
									had spiral-like patterns, which allow the player to lose the enemy through line of sight if the player needs to recover. 
									I also attempted to make the power-ups reflect this too! Fast enemies were more likely to drop speed-boosts, while tanks were
									more likely to drop health-boosts. This allowed players to adapt their strategy based on the biome they were in. Tank enemies
									too strong? Go kill some spread enemies for some extra damage! This appraoched helped ensure the procedural generation
									didn't feel too static; every playthrough felt fresh yet still maintained some sort of consistentcy.
									<br>
									Another important aspect of this level design was the gameplay arc -- the pacing and progression of challenges throughout 
									the level. I wanted to implement a false sense of failure for the hook. Players start with a single heart, no powerups, and
									enemies that were stronger than they are. Balanced so delicately, this largely increased their chance of "dying" at this point,
									but still allowed the player to experiment with controls and combat. When they died, they would respawn, keeping any powerups 
									they may have managed to find, and gaining some extra boosts. This was to reinforce the idea that they had to grow stronger to
									progress, a theme carried out further into the level. This safety net of course only lasted for this beginning phase. Once the
									player first "dies", the deaths are permanent, increasing difficulty. This created an engaging difficulty curve. 
									<br>
									<br>
									<section>
										<h3 class="code-toggle">
											Code Snippets: Enemy Buffs
											<img src="images/DropDown.png" alt="Dropdown Icon">
										</h3>
										<pre><code class="language-cpp">
void SetWeaponStats()
{
	WeaponLogic weapon = GetComponentInChildren<WeaponLogic>();
	if (weapon == null) return; // No weapon attached, exit early

	// Set base stats per enemy type
	SetBaseWeaponStats(weapon);

	// Apply buffs based on which bosses have been killed
	ApplyBossBuffs(weapon);
}

// Sets the base weapon stats per enemy type
void SetBaseWeaponStats(WeaponLogic weapon)
{
	switch (enemyType)
	{
		case EnemyType.BaseEnemy:
			weapon.ShotCooldown = 3f;
			weapon.BulletsPerShot = 1;
			weapon.BulletSpreadAngle = 0.0f;
			weapon.BulletRange = 5.0f;
			weapon.BulletSpeed = 3.0f;
			break;

		case EnemyType.FastEnemy:
			weapon.ShotCooldown = 3f;
			weapon.BulletsPerShot = 1;
			weapon.BulletSpreadAngle = 0.0f;
			weapon.BulletRange = 5.0f;
			weapon.BulletSpeed = 6.0f;
			break;

		case EnemyType.SpreadEnemy:
			weapon.ShotCooldown = 6f;
			weapon.BulletsPerShot = 4;
			weapon.BulletSpreadAngle = 25f;
			weapon.BulletRange = 5.0f;
			weapon.BulletSpeed = 5.0f;
			break;

		case EnemyType.TankEnemy:
			weapon.ShotCooldown = 3f;
			weapon.BulletsPerShot = 3;
			weapon.BulletSpreadAngle = 0.0f;
			weapon.BulletRange = 6.0f;
			weapon.BulletSpeed = 2.0f;
			break;

		case EnemyType.UltraEnemy:
			weapon.ShotCooldown = 5f;
			weapon.BulletsPerShot = 5;
			weapon.BulletSpreadAngle = 50f;
			weapon.BulletRange = 20.0f;
			weapon.BulletSpeed = 5.0f;
			break;

		case EnemyType.BossEnemy:
			weapon.ShotCooldown = 3f;
			weapon.BulletsPerShot = 8;
			weapon.BulletSpreadAngle = 40.0f;
			weapon.BulletRange = 100.0f;
			weapon.BulletSpeed = 4.0f;
			break;
	}
}

// Applies boss kill buffs to the weapon and enemy stats
void ApplyBossBuffs(WeaponLogic weapon)
{
	if (!PCGObject.boss1Killed && !PCGObject.boss2Killed && !PCGObject.boss3Killed && !PCGObject.boss4Killed)
		return; // No buffs to apply, exit early

	// List of boss buffs to apply
	(bool bossKilled, ref bool buffApplied, float shotCooldownReduction, int healthIncrease, float speedIncrease,
		float bulletRangeIncrease, float bulletSpeedIncrease, int bulletsPerShotIncrease, float bulletSpreadIncrease, int aggroRangeIncrease)[] bossBuffs =
	{
		(PCGObject.boss1Killed, ref boss1BuffApplied, -0.3f, 1, 0.25f,  0f,   0f,   2,  0f,  0),
		(PCGObject.boss2Killed, ref boss2BuffApplied, -0.3f, 1, 0.25f,  5.0f, 2f,   0,  0f,  0),
		(PCGObject.boss3Killed, ref boss3BuffApplied, -0.3f, 1, 0.25f,  0f,   0f,   0,  5f,  0),
		(PCGObject.boss4Killed, ref boss4BuffApplied, -0.3f, 1, 0.25f,  0f,   0f,   0,  0f,  5)
	};

	foreach (var (bossKilled, buffApplied, cooldownReduction, healthIncrease, speedIncrease, rangeIncrease, speedBoost, bulletsPerShot, spreadIncrease, aggroIncrease) in bossBuffs)
	{
		if (bossKilled && !buffApplied)
		{
			weapon.ShotCooldown += cooldownReduction;
			Health += healthIncrease;
			Speed += speedIncrease;
			weapon.BulletRange += rangeIncrease;
			weapon.BulletSpeed += speedBoost;
			weapon.BulletsPerShot += bulletsPerShot;
			weapon.BulletSpreadAngle += spreadIncrease;
			AggroRange += aggroIncrease;

			buffApplied = true;
		}
	}

	// TankEnemy and UltraEnemy get extra bonuses
	if (enemyType == EnemyType.TankEnemy || enemyType == EnemyType.UltraEnemy)
	{
		foreach (var (bossKilled, buffApplied, cooldownReduction, healthIncrease, speedIncrease, rangeIncrease, speedBoost, bulletsPerShot, spreadIncrease, aggroIncrease) in bossBuffs)
		{
			if (bossKilled && !buffApplied)
			{
				weapon.ShotCooldown += cooldownReduction;
				Health += (enemyType == EnemyType.TankEnemy ? 2 : healthIncrease);
				Speed += speedIncrease;
				weapon.BulletRange += rangeIncrease;
				weapon.BulletSpeed += speedBoost;
				weapon.BulletsPerShot += bulletsPerShot + (enemyType == EnemyType.UltraEnemy ? 1 : 0);
				weapon.BulletSpreadAngle += spreadIncrease;
				AggroRange += (enemyType == EnemyType.TankEnemy ? 7 : aggroIncrease);

				buffApplied = true;
			}
		}
	}
}
	</code></pre>
	</section>
									<h2>Final Thoughts</h2>
									<br>
									This project was a massive learning experience, beyond simply coding procedural generation. It forced me to think critically
									about level design principles, player agency, and balancing procedural content with structured gameplay. I had to guide the player
									without any explicity directions, avoid repitition and predictability, and ensure that the level was both challenging and engaging.
									Through extensive playtesting and iteration, I learned firsthand how procedural generation isn't just about randomness; it is
									about controlled variation. Level design is not simply building a static world, its preparing for every player to experience
									and see things differently.
									<br>
									Overall this project gave me valuable insights into game systems design, algorithmic level generation, and gameplay balancing,
									skills that will, as always, be invaluable in my future projects!
								</p>
							</article>

						<!-- Work 4 -->
							<article id="work4" class="panel">
								<header>
									<h2>Work 4</h2>
								</header>
								<p>
									<!-- Add your content for Work 4 here -->
									This is the content for Work 4.
								</p>
							</article>

						<!-- Blog -->
							<article id="blog" class="panel">
								<header>
									<h2 class="blur-text">Blog<span class="blinking-cursor">|</span></h2>
								</header>
								<section>
									<h3><a href="#blog1">How Getting Hacked Helped Me</a></h3>
									<p>
										Most people are scared of being hacked, yet do nothing to stop it. Or, they believe they won't ever be a target. 
										But what happens when you <i>do</i> get hacked? And how could it be beneficial?
									</p>
								</section>
								<section>
									<h3><a href="#blog2">The Importance of Connection in the Industry</a></h3>
									<p>
										One single connection can get you further than you ever expected. 
									</p>
								</section>
								<section>
									<h3><a href="#blog3">Blog Post 3</a></h3>
									<p>
										This is the content for Blog Post 3. You can add more details here about your experiences, thoughts, and updates.
									</p>
								</section>
								<section>
									<h3><a href="#blog4">Blog Post 4</a></h3>
									<p>
										This is the content for Blog Post 4. You can add more details here about your experiences, thoughts, and updates.
									</p>
								</section>
							</article>

							<!-- Blog Post 1 -->
							<article id="blog1" class="panel">
								<header>
									<h2>How Getting Hacked Helped Me</h2>
								</header>
								<p>
									The idea of being hacked is something that most people, if not all, fear to some degree. Within this day and age of being 
									constantly connected, your entire life interconnected with the web of the internet, the idea of being hacked is something 
									many people consider to be a nightmare situation. And yet, despite this, I often see time and time again people put themselves
									at risk of being hacked. They use the same password for every account, they click on suspicious links, fall for phishing emails,
									and so on. Whether or not they think they'll ever be a target, or they are simply ignorant, or maybe they just don't know the 
									risks -- the fact remains that they are at risk. 
									<br>
									It is counterintuitive right? To be scared of something, but do nothing to prevent or safeguard from it. Why is it then, that 
									people do this? Oftentimes, convenience and laziness.
									<br>
									This is not to shame anyone -- in fact, it's <i>exactly</i> how I got hacked. I reused passwords, never used two-factor
									authentication, and used the same email for everything. It had worked for years, and I never thought I would be a target.
									I am just a college student after all, they'd only be getting a bunch of PDF files and code that is useless to them. So why 
									bother? But really, your average hacker isn't shooting for the big names. Rarely, if ever, do they do that. But they go for 
									people like me, unsuspecting and unaware of how important keeping yourself, and your data, no matter how insignificant it may
									seem, safe. Low hanging fruit, if you will. 
									<br>
									See, just days before I got hacked, I had actually been researching cybersecurity. Sure, I didn't have things to hide, and at
									the time I didn't believe I had anything worthwhile anyway, but I was curious. I wanted to know how it all worked, how people
									seem entirely anonymous and locked down on the internet, and just overall curiousity. I skimmed over the basics that every source
									tried to bash over my head over and over again, choosing to read the more advanced topics. I figured one day I would jump in 
									myself, becoming some black box within the internet. No one to find me, no one to get my data, and I could have some true 
									privacy. But that "one day" suddenly came much faster than I initially thought.
									<br>
									<br>
									To this day, I have no idea how it happened. I had been working on a GameJam 2025 project with some friends. It was my first
									time ever doing a jam, so I was up all night working on the project. Once I was satisfied with my work for the day, I shut off 
									my computer, and went to bed. My friend encouraged me to swing by his house the next day to work on the project with the team
									in person, so as soon as I woke up, I checked my phone and attempted to message him via Discord. Except, I was logged out. 
									So, I put my same username and password in -- nothing. No matter what I tried, it wouldn't let me in. I had been hacked out of 
									my account. They changed my credentials, tried to steal a couple of dollars, and messaged my friends to try and get them too.
									<br>
									Everyone caught on immediately, thankfully. So while they were safe, I had to scramble and pick up the pieces. All that research
									into cybersecurity was a lot more relavent and useful than I initially thought. This time, I <i>did</i> read thoroughly through
									the basics -- password managers, encryptid emails, two factor authentication... etc. Hours were spent implementing this practices. 
									Sorting through years of emails and logins saved is not for the weak. 
									<br>
									It wasn't easy and it wasn't fun. But I learned a <i>lot</i> from it. Both in simply not being so lazy, but I found a newfound
									interest in cybersecurity. The battle between convenience and security, how easy it is for hackers to get what they want, yet
									how easy it is for you to do the bare minimum lockdown, how strong encryption can help avoid surveillance, and so on. Truly, 
									it was a fascinating read. Getting your hands dirty and having to overcome these obstacles firsthand really forces you to 
									learn quickly. While I know I have much to learn and utilize still, not only did I learn a new skill and interest, but I 
									can confidently say that I am much more safe than I was before. 
								</p>
							</article>

							<!-- Blog Post 2 -->
							<article id="blog2" class="panel">
								<header>
									<h2>The Importance of Connection in the Industry</h2>
								</header>
								<p>
									Have you ever met someone on a chance, only for them to either directly or indirectly change your life? Maybe you initially 
									believed it would be a one time connection, or maybe you figured you'd see them often but never really be recognized. But then,
									through them, everything changes. Maybe they helped set you up with a new amazing job, or helped you get into an exclusive 
									event, or maybe they just gave you a new perspective on life. These connections, no matter how small, can have a massive impact
									on your life.
									<br>
									For those who don't know, I'm currently working to get a degree in Computer Science and Game Design. Both the tech industry
									and game industry are two highly competitive fields, with a lot of people vying for the same positions. I have spent many years
									in college learning about these industries, how to prepare for them, working inside them -- it's a lot of work. The number One
									thing I have learned, however, is that connections are everything. It just takes that one person to change it all. 
									<br>
									Arguably, one of my most important connections came from chance. My years and years of my life, I hoped and dreamed that I would
									be able to attend DigiPen. It was is my dream school. But when high school came around, I went through a real tough part of my life. 
									In part to this rough patch, I almost gave up on attending -- I thought I would be destined to stay in my small hometown, living
									paycheck to paycheck as many unfortunately do there. It isn't exactly a town of opportunity. Many never leave, and many struggle. 
									My high school librarian pushed all of us seniors to apply to colleges, even if we didn't think we could get in. She pushed harder
									than anyone else in my life. With an eyeroll, I figured I would attempt to apply to DigiPen, not expecting much at all. My high
									school didn't even offer many of the things that the college wanted, or required. 
									<br>
									I told some family about this event, thinking nothing of it. And one thing about my family is that they <i>love</i> talking. So 
									word gets around, and eventually reaches my great-uncle's girlfriend, who was a hairdresser for one of the higher executives at
									my dream college. She told him about me, and he told her to tell me to apply. I even got his number where we chatted on the phone
									about what to expect, best ways to apply, life at the school, etc. 
									<br> 
									Just the day before, I didn't even want to apply because I thought I wouldn't get in. But now, I had a direct line to someone
									who pushed me to apply, who gave me the confidence to do so. And so I did. And I got in. My application got reviewed and judged
									compared to thousands of other applicants, and I got in. 
								</p>
							</article>

							<!-- Blog Post 3 -->
							<article id="blog3" class="panel">
								<header>
									<h2>Blog Post 3</h2>
								</header>
								<p>
									This is the detailed content for Blog Post 3. You can add more details here about your experiences, thoughts, and updates.
								</p>
							</article>

							<!-- Blog Post 4 -->
							<article id="blog4" class="panel">
								<header>
									<h2>Blog Post 4</h2>
								</header>
								<p>
									This is the detailed content for Blog Post 4. You can add more details here about your experiences, thoughts, and updates.
								</p>
							</article>


						<!-- Contact -->
							<article id="contact" class="panel">
								<header>
									<h2 class="blur-text">Contact Me!<span class="blinking-cursor">|</span></h2>
								</header>
								<form action="https://formspree.io/f/mdkakyod" method="post">
									<div>
										<div class="row">
											<div class="col-6 col-12-medium">
												<input type="text" name="name" placeholder="Name" />
											</div>
											<div class="col-6 col-12-medium">
												<input type="email" name="email" placeholder="Email" />
											</div>
											<div class="col-12">
												<input type="text" name="subject" placeholder="Subject" />
											</div>
											<div class="col-12">
												<textarea name="message" placeholder="Message" rows="6"></textarea>
											</div>
											<div class="col-12">
												<input type="submit" value="Send Message" />
											</div>
										</div>
									</div>
								</form>
							</article>

						<!-- About Me -->
							<article id="about-me" class="panel">
								<header>
									<h2 class="blur-text">About Me<span class="blinking-cursor">|</span></h2>
								</header>
								<p>
									<!-- Add your text here -->
									<br>
									<em> "The last frontier is the human mind and we are its pioneers." - Prey 2017 </em>
									<br>
									<br>
									Hello!
									<br>
									<br>
									I am TayLee Young, a third year college student at DigiPen Institute of Technology.
									I am currently studying Computer Science and Game Design. I focus in systems programming, 
									data analysis, and game development. I am proficient in C, C++, C#, and I am learning Python, 
									CSS and HTML. I am also familiar with Unity, Unreal Engine, and Visual Studio.
									<br>
									I have worked on several projects, some of which you can find in the Work section. I have 
									worked teams, big and small, and I have experience in project management and team leadership.
									Of course, I am always looking to expand my knowledge and experience.
									<br>
									<br>
									I am deeply motivated to create games that are more than just entertainment. I want to create
									works of art -- art that inspires people to see things in a new light, to create deeply personal
									and provocative worlds, and to challenge the status quo. I want to not only create games,
									but to create experiences that change people's lives.
									<br>
									I am heavily inspired by games like Prey, Night in the Woods, Journey, Silent Hill,
									and Minecraft. These have impacted my life in ways that I never thought possible. Some 
									inspired my path for game design, others have inspired my deep love and appreciation 
									for the art of creation. I will always remember with fondness the first time I played these games,
									as they have made me who I am today!
									<br>
									<br>
									With every project I am in and every team I am apart of, I push strongly for inclusivity, 
									diversity, and accessibility. I believe that games are for everyone. All people, regardless
									of their background, should experience the joy of this art. As a member of the LGBT+ community,
									I know firsthand the importance of representation, inclusion, and acceptance. No one should 
									feel isolated in their experience. This is my mission and goal. To create games that are for
									everyone, that inspire everyone, and that change everyone.
									<br>
									<br>
									Currently, I am apart of team ADMIS, working on a student project about a corrupt corporation,
									aliens, and a big beefy drill. Feel free to read about that too!
									I am looking for internships and job opportunities, so feel free to contact me anytime!
								</p>
							</article>

					</div>

				<!-- Footer -->
					<div id="footer">
						<ul class="copyright">
							<li>&copy; TayLee Young.</li><li>Design: <a href="http://html5up.net">HTML5 UP</a><span class="blinking-cursor">|</span></li>
						</ul>
					</div>

			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>
			<script>
				document.addEventListener('DOMContentLoaded', function() {
					let index = 0;
					const speed = 0.5; // typing speed in milliseconds
		
					function typeWriter() {
						if (index < text.length) {
							document.getElementById("typed-text").innerHTML += text.charAt(index);
							index++;
							setTimeout(typeWriter, speed);
						}
					}
		
					typeWriter();

					let terminalIndex = 0;

					function typeTerminal() {
						if (terminalIndex < terminalText.length) {
							document.getElementById("terminal-text").innerHTML += terminalText.charAt(terminalIndex) === '\n' ? '<br>' : terminalText.charAt(terminalIndex);
							terminalIndex++;
							setTimeout(typeTerminal, speed);
						}
					}

					typeTerminal();
				});
			</script>
	</body>
</html>